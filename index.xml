<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>haKiwata</title><link>https://hakiwata.jp/</link><description>Recent content on haKiwata</description><generator>Hugo -- gohugo.io</generator><copyright>&amp;copy; 2021 haKiwata</copyright><lastBuildDate>Mon, 21 Jun 2021 14:53:48 +0000</lastBuildDate><atom:link href="https://hakiwata.jp/index.xml" rel="self" type="application/rss+xml"/><item><title>このブログを運用する目的</title><link>https://hakiwata.jp/post/20210622/</link><pubDate>Mon, 21 Jun 2021 14:53:48 +0000</pubDate><guid>https://hakiwata.jp/post/20210622/</guid><description>概要 こんにちは！このブログを作成してから早 2 ヶ月が経とうとしています。また、この記事で 10 記事目となる節目でもあります。そこで今回はこのブログを作成した意図やブログを書く目的について改めて考えたいと思います。 背景 自分はそもそも文章を書くことが得意ではありません。そもそも言語化や人に何かを説明するのが苦手です。これは、学部の卒論を書いたときや就活中に痛感しました。Qiita や Hatena Blog を使って文章を書く練習しようと試みたこともありましたが、継続的に文章を書くことができませんでした。 また、記憶力が悪く、例えば何か問題を解決した時のプロセスを詳しく思い出すことが苦手です。そこで、この自作ブログを運用して育てることを通して、これらの苦手なことを苦手に感じないレベルまで引き上げればと考えています。そして、それに乗じて他人に目に晒すアウトプットができればと考えています。 ブログを書くに当たっての目的とルール ブログを書く目的は以下のように考えています。 言語化能力を上げる。 一定のフォーマットに従って論理的に素早く文章を書く練習をする。 思考プロセスを論理的に振り返る練習をする。 アウトプットを意識してインプットする場として存在させる。 人との会話における引き出しにする。 そして、ブログを書くに当たって自分なりに決めたルールは以下のように考えています。 月 1 件は何か記事を書くこと。数をこなすことを目的にしない。 論理的に正しいわかりやすい文章を書くこと。 技術や勉強したことをアウトプットすること。 特に厳しいルールは課していません。それは、継続的に何かをアウトプットする意識が大事だと考えているからです。今取り組んでいることがブログのネタにならないか、あるいは、今考えているとを拡張すればネタにできないかとアウトプット前提とした普段からの意識付けが何よりも大切だと思っています。
最近では、この意識付けのおかげで、技術的な問題を解決した際に、その解決における思考プロセスを意識的に振り返る習慣を少しずつ付けることができています。こうして、ブログを書くことで良い傾向が日に日に現れています。
現時点でブログを書き続けられている理由と最終目標 これまでは、Qiita や Hatena Blog を使ってブログを書き続けることができなかったのに、自作ブログではブログを書き続けられるようになったのは、飛躍がある気がします。これまでできなかったことができるようになるのには理由があるはずです。これはおそらく、精神的な余裕がある中で自由に時間を過ごせる権利が現時点であるからではと考えています。そのため、社会人になったらブログを書き続けられないかもしれません。しかし、それまでに毎月何件かはブログを書かないと気持ち悪くなるぐらいに、習慣化できればと考えています。 最後に 自前でブログを作るのは面倒臭かったです。しかし、今ではこのブログを育てて行きたいと思えているので、作って良かったです。気負いせずに継続的にブログを書くことで、論理的な文章を書く力を上げていきます🤞</description></item><item><title>システムコール番号を使って write システムコールを呼び出す</title><link>https://hakiwata.jp/post/20210618/</link><pubDate>Fri, 18 Jun 2021 02:21:38 +0900</pubDate><guid>https://hakiwata.jp/post/20210618/</guid><description>概要 こんにちは！最近、低レイヤ寄りの実装に興味があり、Linux Kernel のシステムコール周りのソースコードを読む機会がありました。その際に、システムコールには、対応するシステムコール番号があるのを知りました。そこで、今回は C 言語やアセンブリ言語を書くことを通して、write システムコールにおけるシステムコール番号とシステムコールの関係性について調査してみたいと思います。 背景と目的 あるとき、socket システムコールは第三引数の protocol に応じてどのような処理が行われているかが気になったことがありました。その際、socket システムコールのプログラムを Linux Kernel のソースコードから紐解く静的解析を行いました。静的解析でプログラムを追っていくと、write システムコールが呼び出されていることに気づきました。このことがキッカケで、一番プリミティブで親近感のある write システムコールの実装やシステムコール番号との関係性に興味を持ちました。
そこで、今回は検証プログラムを実装することを通して、write システムコールにおけるシステムコール番号とシステムコールの関係性を明らかにします。
方法 以下の 1 と 2 と 3 の順序で検証を行います。 まず、syscall 関数とシステムコール番号を使用して標準出力に文字列を出力する C 言語のプログラムを実装します。これにより、システムコール番号とシステムコールの対応関係に対する理解を深めます。
次に、アセンブリ言語単体でシステムコールを呼び出すプログラムを実装します。これにより、システムコールを呼び出す際に必要な引数をスタックに詰んで、システムコールを呼び出す流れを確認します。
最後に、アセンブリ言語でシステムコールを呼び出し、標準出力に文字列を出力させる関数を実装し、その関数を C 言語で書いたプログラムから呼び出します。こうして、C 言語で書いたプログラムとアセンブリ言語で書いたプログラムの関係性を確認します。ただし、ここで取り扱うアセンブリ言語のプログラムは 32 bit の実行ファイルを作成するためのプログラムです。
それでは、1 を検証したいと思います。 まず、syscall 関数のマニュアルを確認すると、以下のような記述がありました。 NAME syscall - indirect system call SYNOPSIS #define _GNU_SOURCE /* See feature_test_macros(7) */ #include &amp;lt;unistd.</description></item><item><title>5 月の振り返り</title><link>https://hakiwata.jp/post/20210615/</link><pubDate>Tue, 15 Jun 2021 00:34:14 +0900</pubDate><guid>https://hakiwata.jp/post/20210615/</guid><description>概要 こんにちは！振り返りでは 1 月 ~ 4 月に勉強したことを振り返りました。しかし、6 月に入っても未だに 5 月に勉強したことをブログに書いて振り返ることができていませんでした。そこで、今回は 5 月に勉強したことを毎日メモしているノートを参考にザックリまとめたいと思います。 勉強したこと ここには、趣味で勉強したことと大学院生活に関するに分けて書きました。 趣味に関すること C 言語で Exercism を 2 問解きました。 自作エディタ keditor を実装しました。 参考にする自作エディタ kilo のコードリーディングを行いました。 また、Build Your Own Text Editor を読みました。これは kilo の解説記事です。そのため、コードリーディングにおける自分の解釈と照らし合わせながら読みました。この際に、必要なライブラリや処理の調査と検証をログに残しつつ行いました。 上のプロセスを経て keditor を実装しました。 Linux のシステムコールの静的解析を行いました。 この内容はブログにしようと思いながら時間が経ってしまっています。今月中には書きたいと考えています。 C 言語で #include &amp;lt;stdio.h&amp;gt; を行わずに Hello World を標準出力に表示させました。 この内容はブログにしようと思いながら時間が経ってしまっています。今月中には書きたいと考えています。 基礎からわかるTCP/IP ネットワーク実験プログラミング（第2版） を読みました。 詳しくは Network Programming の基礎を学んだ に書きました。 ProjectEuler を 24 問解きました。 Heroku 上に Flask で作成した REST API をデプロイしました。 プログラミングの基礎を読み始めました。 ブログを 3 本書きました。 研究に関すること 研究の進捗報告を 1 回しました。 大学院の講義のレポートを何本か書きました。 感想 こうして振り返ってみると、異常に多くのことをこなしていてビックリしました。もちろん GW があったのが一つの理由ではあると思います。毎日つけているノートを振り返ると、そういやこんなことしてたなぁと思い返したり、やり残していることに気づいたりと、色々と振り返ることができて良かったです。一方で今月はあまり進んでいない気もしてきました。今月も折り返していますので、残りの後半も頑張りたいと思います！ 参考 Exercism keditor BinaryAnalysisBook/s6 kiso_tcp flask-api</description></item><item><title>.gitconfig を使って untracked files のみを退避させる</title><link>https://hakiwata.jp/post/20210613/</link><pubDate>Sun, 13 Jun 2021 06:13:26 +0900</pubDate><guid>https://hakiwata.jp/post/20210613/</guid><description>概要 自分で運用しているブログサイトは git を用いて管理しています。新しい記事を作成する際に、untracked files のみを git stash して、退避させたいことがありました。しかし、git にはデフォルトで untracked files のみを退避させるコマンドは無いそうです。そこで、今回は .gitconfig を使用して工夫したことについての記録を残したいと思います。 背景と目的 新しい記事を作成するために hugo new コマンドで記事の雛形を作成します。過去に書いた記事を参考にしつつ新しい記事を書いていると、過去の記事にタイポを見つけて修正したくなることや、言い回しを変えたくなる時があります。その内容を修正しつつ、一通り満足の行く新しい記事を書き終えると、hugo コマンドで修正したり作成したファイルを build を行った後に push する必要があります。しかし、修正した過去の記事と新規作成した記事の build を別々に行った後に push してコミットを分けたいと考えています。そのため、このようなケースでは一旦新規作成した記事を退避させて build を行い、push します。そして、その後に git stash pop で退避させた新規作成した記事を元に戻してから build を行い、push するようにします。
こうして untracked files のみを退避させたいのですが、このコマンドは毎回調べているイメージがありました。その調べている時間が無駄でもったいないと感じていました。そこで、今回はその無駄な手順を省くために .gitconfig を使用し、 untracked files のみを退避させるエイリアスを設定しました。また、.bashrc に記述していた git コマンドのエイリアスも .gitconfig に移して、設定ファイルの整理も行いました。
方法 untracked files のみを退避させる方法は How to git stash only untracked files?</description></item><item><title>Hugo のテンプレートを修正してみた</title><link>https://hakiwata.jp/post/20210611/</link><pubDate>Fri, 11 Jun 2021 17:37:01 +0900</pubDate><guid>https://hakiwata.jp/post/20210611/</guid><description>概要 こんにちは！自分の Web サイトは Hugo を用いて運用しています。これまでは、デフォルトの設定で特に大きく変更すること無く使用していました。しかし、表示するコンテンツを追加したいと思い、思い切ってテンプレートに修正を加えていくことにしました。今回は、その際に行った修正などについての記録を残したいと思います。 背景と目的 記事を新しく追加していくと、Latest Posts の記事から、メモ的なお気に入りの記事が埋もれてしまう問題点がありました。現状の設定では Latest Posts に表示される記事の数は 5 件です。そこで、トップページに Favorite Posts の項目を追加し、メモ的なお気に入りの記事を表示させるようにしました。 方法 上述の目的を成し遂げるために以下の 3 つのことを行いました。 archetypes/default.md の Front Matter Variables に favorite: false を追加します。このパラメータは Favorite Posts の箇所に記事を表示させるかのフラグです。 Favorite Posts に表示させたい記事の Front Matter Variables に favorite: true を追記します。 themes/manis-hugo-theme/layouts/index.html を修正します。favorite: true の記事をフィルタリングし、 Favorite Posts を表示するようなロジックを追加します。 3 に関しては Latest Post のプログラムと公式のドキュメントの Hugo の文法を参考に実装しました。特に、Nest where Clauses が参考になりました。 感想 実装したい機能から逆算して修正すべきファイルに当たりをつけて、リバースエンジニアリング的に機能を拡張できて楽しかったです。Hugo は Golang の機能を活用して実装されています。Golang や Hugo に詳しいわけではないのですが、公式ドキュメントを読んでいると Hugo の文法も少し知ることができました。こうして、なんとか実現したい機能を調査と検証を繰り返しながら実装できて良かったです。また少し技術力が上がった気がします。 参考 Front Matter Nest where Clauses hakiwata/issues/3</description></item><item><title>関数型プログラミングに入門した</title><link>https://hakiwata.jp/post/20210610/</link><pubDate>Thu, 10 Jun 2021 01:34:28 +0900</pubDate><guid>https://hakiwata.jp/post/20210610/</guid><description>概要 こんにちは！先月末から プログラミングの基礎 を読んでいました。普段は Python や C 言語でプログラムを書くことが多いのですが、この本を通して、関数型プログラミングに入門しました。丁度今日に読み終えたので、なぜ読み始めたのかや何を学んだかなどの記録を残したいと思います。 読み始めたきっかけと目的 この本を読もうと思ったきっかけは、関数型プログラミングを通して再帰の概念や多相型について学びたいと思ったからです。2, 3 年前までは競技プログラミングをしていたのですが、その時に再帰的なプログラムを書くのに苦手意識を感じていました。典型的な再帰の問題は解けるのですが、少し難しい応用的な問題が出ると、お手上げな状態でした。実務などで頻繁に使うイメージはないのですが、前々から苦手意識は潰しておきたいと思っていました。そのため、関数型プログラミング言語の OCaml を通して再帰的なデータ構造や多相型について学ぶことが、この本を読む目的でした。 学んだこと この本を通して学んだことを列挙します。 プログラムを書く際のデザインレシピとその実践 関数の目的と入出力の型を考える 関数のテストケース (具体例) を考える 関数のテンプレート (骨組み) を実装する 以上のことを基に関数の本体を実装する テストケースに従って関数をテストする 再帰的なプログラミング リスト自体が再帰的なデータ構造である 数学的帰納法をイメージするとわかりやすい リストを定義するには、要素とリストが必要なので、再帰的なデータ構造となる 関数の抽象化 多相型を使用したデータ構造 エラーハンドリング 紹介 ここでは、紹介されていたプログラムの中で、なるほど！と思ったプログラムについて紹介したいと思います。
接頭語のリストから全ての接頭語のリストを返す関数 prefix を実装することがこの章での目的です。例えば [1; 2; 3; 4] のリストを受け取ると、[[1]; [1; 2]; [1; 2; 3]; [1; 2; 3; 4]] を返す関数の実装です。</description></item><item><title>Network Programming の基礎を学んだ</title><link>https://hakiwata.jp/post/20210529/</link><pubDate>Sat, 29 May 2021 00:08:15 +0900</pubDate><guid>https://hakiwata.jp/post/20210529/</guid><description>概要 こんにちは！ゴールデンウィーク明けから 基礎からわかるTCP/IP ネットワーク実験プログラミング（第2版） を読んでいました。この本は マスタリングTCP/IP―入門編―(第6版) の著者の一人である 村山公保先生 が書かれた本です。丁度今日に読み終えたので、なぜ読み始めたのかや何を学んだかなどの記録を残したいと思います。 読み始めたきっかけと目的 この本を読もうと思ったきっかけは、システムプログラミングをしつつ、ネットワークプロトコル (Ethernet/ARP/IP/ICMP/TCP/UDP) を C 言語のプログラムレベルで理解したいと思ったからです。例えば TCP のヘッダの構造体は Ubuntu のどのパスに定義されていて、それを用いて、システムコールをどのように呼び出せば TCP のパケットを作って通信できるかなどです。大学/大学院の講義やマスタリングTCP/IP や普段の Web プログラミングを通して、基本的な通信の概念は知っていました。しかし、プロトコルをプログラムレベルでイメージできるほどは理解できていませんでした。そのため、ネットワークプロトコルの実装が C 言語のプログラムレベルでイメージできるようになることが、この本を読む目的でした。 学んだこと この本を通して学んだことを列挙します。
プログラムレベルでのプロトコルの解説 ネットワークプロトコルに必要な構造体、システムコール、ライブラリ関数の使い方とそれらの調査方法 socket システムコールを用いた UDP Client/UDP Server の実装 socket システムコールを用いた TCP Client/TCP Server の実装 パケットモニタリングを行い Ethernet/ARP/IP/ICMP/TCP/UDP のヘッダの解析 IP スキャン / TCP ポートスキャン / UDP ポートスキャン の実装 ARP 要求パケットや ARP 応答パケットを用いた対象のホストの ARP テーブルを書き換える攻撃手法の実装 ICMP redirect を用いた対象のホストのルーティングテーブルを書き換える攻撃手法の実装 IP ヘッダの TTL を用いた traceroute コマンドのようなものを実装 TCP のヘッダを作成し、SYN flood 攻撃の実装 TCP のヘッダを作成し、 ESTABLISHED な TCP のコネクションを強制的に切断する攻撃手法の実装 TCP のヘッダを作成し、TCP ジャックをする攻撃手法の実装 システムコールを用いた自作クライアントとサーバの実装、パケットモニタリング、攻撃手法の再現を通して、ネットワークプロトコルの構造や各レイヤーの関係性を学ぶことができました。読み応えのある非常に良い本でした。理解があやふやな箇所もあるので、期間を空けて本を読み直したいと思いました。</description></item><item><title>今年中に一つでも多く勉強したいこと</title><link>https://hakiwata.jp/post/20210518/</link><pubDate>Tue, 18 May 2021 04:27:07 +0900</pubDate><guid>https://hakiwata.jp/post/20210518/</guid><description>概要 こんにちは！最近は、ネットワーク周りのシステムコールやライブラリ関数の調査と検証が多く、わかりやすい進捗が出ていない気がしています。そこで、気晴らしに今年中に勉強したいことを洗い出してみました。一旦アウトプットすることで、頭の中がクリアになればと思っています。 勉強したい内容 今年入って勉強してきたことの上乗せ 基礎からわかるTCP/IP ネットワーク実験プログラミング（第2版） を読む
ネットワークのパケットを C 言語のプログラムレベルで理解したい。 ハロー“Hello, World” OSと標準ライブラリのシゴトとしくみ を読む
動的解析の観点からシステムコールを学びたい。 サイバーセキュリティプログラミング ―Pythonで学ぶハッカーの思考 を読む
セキュリティの観点から年のパケットをプログラムレベルで理解したい。 Hacking: 美しき策謀 第2版 ―脆弱性攻撃の理論と実際 を読む
今年に学んだことを PWN などに応用して、セキュリティ的な観点からも更に理解を深めたい。 低レベルプログラミング を読む
アセンブリ言語や C 言語や型システムを学びたい。 また、今年は、C 言語やアセンブリ言語を勉強してきたので、新たな書籍で体系的に学びたい。 例解UNIX/Linuxプログラミング教室: システムコールを使いこなすための12講 を読む
今年は、シスプロを多めに勉強してきたので、違う書籍の違う観点から新しい知見を得たい。 ふつうの Linux プログラミングの Http Server の章を読み直す</description></item><item><title>振り返り</title><link>https://hakiwata.jp/post/20210512/</link><pubDate>Wed, 12 May 2021 03:07:55 +0900</pubDate><guid>https://hakiwata.jp/post/20210512/</guid><description>概要 こんにちは！今年も月日が経つのが早く 1 年の内の 1/3 が過ぎ去ってしまいました。後輩や友達に今年に入って何を勉強してきたのかを聞かれることがたまにあるので、その記録を残していきたいと思います。基本的に大学院の課題や研究は除いています。 1 月 そもそも今年のテーマは Computer Science の基礎を固めることでした。もう少し具体的に言うと、OS, CPU, Network, Container の仕組みをコードレベルで勉強したいと考えていました。そこで、まずコンピュータの全体像を掴むために、以下の本を 2 月中旬まで読んでいました。
コンピュータシステムの理論と実装 ―モダンなコンピュータの作り方 この本は Nand to Tetris とも呼ばれるのですが、CPU を構成する回路 (例えば全加算器や ALU) を VHDL で実装して、エミュレータで動かすところからレイヤーを徐々に上げていきます。作成した基本的な回路を元に、CPU をエミュレートします。その後、機械語やアセンブリ言語やスタックを学び、VM、独自言語のコンパイラをインクリメンタルに実装していきます。この本と付随する演習問題を全て解くことを通して、 CPU や VM と言った普段は意識しない低レイヤなものの振る舞いをなんとなくイメージできるようになりました。
2 月 コンピュータシステムの理論と実装を読んで、特にアセンブリとコンパイラに興味を持ちました。そこで、以下の本と資料を読み始めました。
はじめて学ぶバイナリ解析　不正なコードからコンピュータを守るサイバーセキュリティ技術 低レイヤを知りたい人のためのCコンパイラ作成入門 前者に関しては、CTFer にはおなじみですが、セキュリティ的な観点からスタックやアセンブリを学べました。初心者向けの本だったので、コンピュータシステムの理論と実装の復習にもなり、学びになりました。
後者に関しては、 C 言語のコンパイラをテストコードと共にインクリメンタルに実装していくものです。このコンパイラを実装できれば、自作コンパイラのコードそのものや、xv6 をコンパイルできるとワクワクしていました。しかし、C 言語の理解が学部 1 年生レベルで止まっていたこともあり、型をコンパイルしてアセンブリを吐き出せるようになる手前で挫折してしまいました。毎日付けているノートを振り返ると、C 言語の理解の浅さとアセンブリ言語の知識が足りなかったと反省しています。</description></item><item><title>First Post</title><link>https://hakiwata.jp/post/20210430/</link><pubDate>Fri, 30 Apr 2021 03:03:17 +0900</pubDate><guid>https://hakiwata.jp/post/20210430/</guid><description>サイトの移行 こんにちは！もともと自分のポートフォリオを Amazon EC2 にデプロイしていたのですが、AWS Education で割り当てられたクレジットが切れたので、Hugo + GitHub Pages で新しく作り直しました。思い立って 2 時間ほどで移行できたので、非常に便利だと思いました。</description></item></channel></rss>