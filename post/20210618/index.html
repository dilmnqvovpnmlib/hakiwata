<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.83.1"><title>システムコール番号を使って write システムコールを呼び出す - haKiwata</title><meta name=description content="概要  こんにちは！最近、低レイヤ寄りの実装に興味があり、Linux Kernel のシステムコール周りのソースコードを読む機会がありました。その際に、システムコールには、対応するシステムコール番号があるのを知りました。そこで、今回は C 言語やアセンブリ言語を書くことを通して、write システムコールにおけるシステムコール番号とシステムコールの関係性について調査してみたいと思います。  背景と目的   あるとき、socket システムコールは第三引数の protocol に応じてどのような処理が行われているかが気になったことがありました。その際、socket システムコールのプログラムを Linux Kernel のソースコードから紐解く静的解析を行いました。静的解析でプログラムを追っていくと、write システムコールが呼び出されていることに気づきました。このことがキッカケで、一番プリミティブで親近感のある write システムコールの実装やシステムコール番号との関係性に興味を持ちました。
  そこで、今回は検証プログラムを実装することを通して、write システムコールにおけるシステムコール番号とシステムコールの関係性を明らかにします。
  方法  以下の 1 と 2 と 3 の順序で検証を行います。    まず、syscall 関数とシステムコール番号を使用して標準出力に文字列を出力する C 言語のプログラムを実装します。これにより、システムコール番号とシステムコールの対応関係に対する理解を深めます。
  次に、アセンブリ言語単体でシステムコールを呼び出すプログラムを実装します。これにより、システムコールを呼び出す際に必要な引数をスタックに詰んで、システムコールを呼び出す流れを確認します。
  最後に、アセンブリ言語でシステムコールを呼び出し、標準出力に文字列を出力させる関数を実装し、その関数を C 言語で書いたプログラムから呼び出します。こうして、C 言語で書いたプログラムとアセンブリ言語で書いたプログラムの関係性を確認します。ただし、ここで取り扱うアセンブリ言語のプログラムは 32 bit の実行ファイルを作成するためのプログラムです。
    それでは、1 を検証したいと思います。 まず、syscall 関数のマニュアルを確認すると、以下のような記述がありました。  NAME syscall - indirect system call SYNOPSIS #define _GNU_SOURCE /* See feature_test_macros(7) */ #include <unistd."><link rel="shortcut icon" href=https://hakiwata.jp/img/images/kiwata.png><link rel=stylesheet href=https://hakiwata.jp/css/ui.css><link rel=stylesheet href=https://hakiwata.jp/css/main.css><link rel=stylesheet href="https://fonts.googleapis.com/css?family=Fira+Mono|Lato|Raleway"><meta property="og:title" content="システムコール番号を使って write システムコールを呼び出す"><meta property="og:description" content="概要  こんにちは！最近、低レイヤ寄りの実装に興味があり、Linux Kernel のシステムコール周りのソースコードを読む機会がありました。その際に、システムコールには、対応するシステムコール番号があるのを知りました。そこで、今回は C 言語やアセンブリ言語を書くことを通して、write システムコールにおけるシステムコール番号とシステムコールの関係性について調査してみたいと思います。  背景と目的   あるとき、socket システムコールは第三引数の protocol に応じてどのような処理が行われているかが気になったことがありました。その際、socket システムコールのプログラムを Linux Kernel のソースコードから紐解く静的解析を行いました。静的解析でプログラムを追っていくと、write システムコールが呼び出されていることに気づきました。このことがキッカケで、一番プリミティブで親近感のある write システムコールの実装やシステムコール番号との関係性に興味を持ちました。
  そこで、今回は検証プログラムを実装することを通して、write システムコールにおけるシステムコール番号とシステムコールの関係性を明らかにします。
  方法  以下の 1 と 2 と 3 の順序で検証を行います。    まず、syscall 関数とシステムコール番号を使用して標準出力に文字列を出力する C 言語のプログラムを実装します。これにより、システムコール番号とシステムコールの対応関係に対する理解を深めます。
  次に、アセンブリ言語単体でシステムコールを呼び出すプログラムを実装します。これにより、システムコールを呼び出す際に必要な引数をスタックに詰んで、システムコールを呼び出す流れを確認します。
  最後に、アセンブリ言語でシステムコールを呼び出し、標準出力に文字列を出力させる関数を実装し、その関数を C 言語で書いたプログラムから呼び出します。こうして、C 言語で書いたプログラムとアセンブリ言語で書いたプログラムの関係性を確認します。ただし、ここで取り扱うアセンブリ言語のプログラムは 32 bit の実行ファイルを作成するためのプログラムです。
    それでは、1 を検証したいと思います。 まず、syscall 関数のマニュアルを確認すると、以下のような記述がありました。  NAME syscall - indirect system call SYNOPSIS #define _GNU_SOURCE /* See feature_test_macros(7) */ #include <unistd."><meta property="og:type" content="article"><meta property="og:url" content="https://hakiwata.jp/post/20210618/"><meta property="og:image" content="https://hakiwata.jp/img/images/kiwata.png"><meta property="article:section" content="post"><meta property="article:published_time" content="2021-06-18T02:21:38+09:00"><meta property="article:modified_time" content="2021-06-18T02:21:38+09:00"><meta name=twitter:card content="summary"><script async src="https://www.googletagmanager.com/gtag/js?id=G-YXCYPL25QW"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag('js',new Date),gtag('config','G-YXCYPL25QW',{anonymize_ip:!1})}</script></head><body><header class="container no-print"><div class=u-header><nav class=bar><ul><li><a href=https://hakiwata.jp/><img class=icon-text src=https://hakiwata.jp/img/prev.svg></a></li><li><a href=https://hakiwata.jp/about>About</a></li><li><a href=https://hakiwata.jp/post>Post</a></li><li><a href=https://hakiwata.jp/scraps>Scraps</a></li><li><a href=https://hakiwata.jp/tags>Tags</a></li></ul></nav></div></header><main class=container><article><header><hgroup id=brand><h1>システムコール番号を使って write システムコールを呼び出す</h1><h5><time datetime="2021-06-18 02:21:38 +0900 +0900">Jun 18, 2021</time>
<span class=no-print>-
<a href=https://hakiwata.jp/tags/c>C</a>
<a href=https://hakiwata.jp/tags/assembler>Assembler</a>
<span></h5></hgroup><hr class=sep></header><h2 id=概要>概要</h2><ul><li>こんにちは！最近、低レイヤ寄りの実装に興味があり、<a href=https://github.com/torvalds/linux>Linux Kernel</a> のシステムコール周りのソースコードを読む機会がありました。その際に、システムコールには、対応するシステムコール番号があるのを知りました。そこで、今回は C 言語やアセンブリ言語を書くことを通して、<a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/write.2.html>write</a> システムコールにおけるシステムコール番号とシステムコールの関係性について調査してみたいと思います。</li></ul><h2 id=背景と目的>背景と目的</h2><ul><li><p>あるとき、<a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/socket.2.html>socket</a> システムコールは第三引数の <code>protocol</code> に応じてどのような処理が行われているかが気になったことがありました。その際、<a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/socket.2.html>socket</a> システムコールのプログラムを <a href=https://github.com/torvalds/linux>Linux Kernel</a> のソースコードから紐解く静的解析を行いました。静的解析でプログラムを追っていくと、<a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/write.2.html>write</a> システムコールが呼び出されていることに気づきました。このことがキッカケで、一番プリミティブで親近感のある <a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/write.2.html>write</a> システムコールの実装やシステムコール番号との関係性に興味を持ちました。</p></li><li><p>そこで、今回は検証プログラムを実装することを通して、<a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/write.2.html>write</a> システムコールにおけるシステムコール番号とシステムコールの関係性を明らかにします。</p></li></ul><h2 id=方法>方法</h2><ul><li>以下の 1 と 2 と 3 の順序で検証を行います。</li></ul><ol><li><p>まず、<a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/syscall.2.html>syscall</a> 関数とシステムコール番号を使用して標準出力に文字列を出力する C 言語のプログラムを実装します。これにより、システムコール番号とシステムコールの対応関係に対する理解を深めます。</p></li><li><p>次に、アセンブリ言語単体でシステムコールを呼び出すプログラムを実装します。これにより、システムコールを呼び出す際に必要な引数をスタックに詰んで、システムコールを呼び出す流れを確認します。</p></li><li><p>最後に、アセンブリ言語でシステムコールを呼び出し、標準出力に文字列を出力させる関数を実装し、その関数を C 言語で書いたプログラムから呼び出します。こうして、C 言語で書いたプログラムとアセンブリ言語で書いたプログラムの関係性を確認します。ただし、ここで取り扱うアセンブリ言語のプログラムは 32 bit の実行ファイルを作成するためのプログラムです。</p></li></ol><hr><ul><li>それでは、1 を検証したいと思います。</li><li>まず、<a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/syscall.2.html>syscall</a> 関数のマニュアルを確認すると、以下のような記述がありました。</li></ul><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>NAME
       syscall - indirect system call

SYNOPSIS
       <span class=c1>#define _GNU_SOURCE         /* See feature_test_macros(7) */</span>
       <span class=c1>#include &lt;unistd.h&gt;</span>
       <span class=c1>#include &lt;sys/syscall.h&gt;   /* For SYS_xxx definitions */</span>

       long syscall<span class=o>(</span>long number, ...<span class=o>)</span><span class=p>;</span>

DESCRIPTION
       syscall<span class=o>()</span>  is  a  small  library  <span class=k>function</span>  that invokes the system call whose assembly language interface has the specified number with the specified arguments.
       Employing syscall<span class=o>()</span> is useful, <span class=k>for</span> example, when invoking a system call that has no wrapper <span class=k>function</span> in the C library.

       syscall<span class=o>()</span> saves CPU registers before making the system call, restores the registers upon <span class=k>return</span> from the system call, and stores any error code returned  by  the
       system call in errno<span class=o>(</span>3<span class=o>)</span> <span class=k>if</span> an error occurs.

       Symbolic constants <span class=k>for</span> system call numbers can be found in the header file &lt;sys/syscall.h&gt;.
</code></pre></div><ul><li>つまり、<a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/syscall.2.html>syscall</a> 関数の第一引数にシステムコール番号を、それ以降の可変長引数にそのシステムコール番号に対応するシステムコールの引数を格納して呼び出せば、システムコールを呼び出せそうです。そこで、以下のようなプログラム <code>test_1.c</code> を実装して検証しました。</li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=cp>#define _GNU_SOURCE
</span><span class=cp>#include</span> <span class=cpf>&lt;unistd.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;sys/syscall.h&gt;</span><span class=cp>
</span><span class=cp>#include</span> <span class=cpf>&lt;asm/unistd_32.h&gt;</span><span class=cp>
</span><span class=cp></span>
<span class=kt>int</span> <span class=nf>main</span><span class=p>(</span><span class=kt>void</span><span class=p>)</span> <span class=p>{</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>buf</span> <span class=o>=</span> <span class=s>&#34;Hi!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
    <span class=n>syscall</span><span class=p>(</span><span class=n>__NR_write</span><span class=p>,</span> <span class=n>STDOUT_FILENO</span><span class=p>,</span> <span class=n>buf</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>buf</span><span class=p>));</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><ul><li>このプログラムを以下のコマンドでビルドをします。</li></ul><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>gcc -m32 -o test_1 test_1.c
</code></pre></div><ul><li>作成された実行ファイルを以下のコマンドで実行します。</li></ul><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>./test_1
Hi!
</code></pre></div><ul><li><p>このように <code>Hi!</code> の文字列が標準出力に出力されます。こうして、<a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/syscall.2.html>syscall</a> 関数とシステムコール番号を使って <a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/write.2.html>write</a> システムコールを呼び出すことができました。</p></li><li><p>ちなみに、システムコール番号は以下のコマンドを使用して確認しました。システムコール番号の変数名はマクロで定義されていて、<code>__NR</code> の文字列が入っていたのが経験的に知っていました。しかし、その変数名を正確には記憶していませんでした。そのため、以下のコマンドでシステムコール番号を確認しました。</p></li></ul><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>grep -ilr __NR /usr/include/* 
</code></pre></div><ul><li>このコマンドの結果の一部を抜粋して以下に記載します。</li></ul><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>/usr/include/asm/vsyscall.h
/usr/include/asm/unistd_64.h
/usr/include/asm/unistd_x32.h
/usr/include/asm/unistd_32.h
/usr/include/asm-generic/unistd.h
/usr/include/bits/unistd.h
/usr/include/bits/syscall.h
/usr/include/bits/stdlib.h
...
</code></pre></div><ul><li>とりあえずシステムコール番号が定義されていそうな雰囲気のある <code>/usr/include/asm/unistd_32.h</code> を確認すると、マクロで <code>#define __NR_write 4</code> が定義されているのが確認できると思います。つまり、<a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/write.2.html>write</a> システムコールのシステムコール番号が <code>4</code> であることが確認できました。</li></ul><hr><ul><li><p>次に、2 を検証したいと思います。</p></li><li><p>以下のテーブルは、レジスタにどのような値をロードする必要があるかを表しています。これは <a href=https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#calling-conventions>Linux System Call Table</a> を参考に作成しています。32 bit の実行ファイルで <a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/write.2.html>write</a> システムコールを呼び出すのであれば、<code>eax</code> レジスタにはシステムコール番号を、<code>ebx</code> レジスタには呼び出すシステムコールの第一引数を、<code>ecx</code> レジスタには第二引数を、<code>edx</code> レジスタには第三引数をロードし、<code>int 0x80</code> を呼び出すようにアセンブリ言語を書く必要があります。</p></li></ul><table><thead><tr><th style=text-align:center>arch</th><th style=text-align:center>syscall NR</th><th style=text-align:center>return</th><th style=text-align:center>arg0</th><th style=text-align:center>arg1</th><th style=text-align:center>arg2</th><th style=text-align:center>arg3</th><th style=text-align:center>arg4</th><th style=text-align:center>arg5</th></tr></thead><tbody><tr><td style=text-align:center>x86</td><td style=text-align:center>eax</td><td style=text-align:center>eax</td><td style=text-align:center>ebx</td><td style=text-align:center>ecx</td><td style=text-align:center>edx</td><td style=text-align:center>esi</td><td style=text-align:center>edi</td><td style=text-align:center>ebp</td></tr></tbody></table><ul><li><p>これを元にレジスタに具体的な値をロードしていきます。<code>eax</code> には <code>__NR_write</code> の値である <code>4</code> を、<code>ebx</code> には標準出力を表す <code>1</code> を格納します。表示する文字列 <code>Hi!</code> に関しては、スタック経由で <code>ecx</code> に文字列の先頭のアドレスをロードします。今回は、最初に <code>push 0x0a216948</code> でスタックのトップに表示したい文字列を積んでいます。したがって、このアドレスを <code>ecx</code> にロードすれば良いです。最後に、<code>edx</code> には、表示する文字列のバイト数 <code>4</code> をロードします。</p></li><li><p>こうして、標準出力に <code>Hi!</code> の文字列を出力するプログラム <code>test_2.asm</code> を以下に記述します。</p></li></ul><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm><span class=nf>global</span> <span class=no>main</span>

<span class=nl>main:</span>
  <span class=nf>push</span> <span class=mi>0x0a216948</span>
  <span class=nf>mov</span>  <span class=no>eax</span><span class=p>,</span> <span class=mi>0x4</span>
  <span class=nf>mov</span>  <span class=no>ebx</span><span class=p>,</span> <span class=mi>0x1</span>
  <span class=nf>mov</span>  <span class=no>ecx</span><span class=p>,</span> <span class=no>esp</span>
  <span class=nf>mov</span>  <span class=no>edx</span><span class=p>,</span> <span class=mi>0x4</span>
  <span class=nf>int</span>  <span class=mi>0x80</span>
  <span class=nf>add</span>  <span class=no>esp</span><span class=p>,</span> <span class=mi>0x4</span>
</code></pre></div><ul><li>次に、<a href=https://www.nasm.us/>nasm</a> コマンドを用いてアセンブリ言語で書かれたプログラムをオブジェクトファイルに変換します。この変換には以下のコマンドを実行します。</li></ul><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>nasm -g -f elf32 -o test_2.o test_2.asm
</code></pre></div><ul><li>生成されたオブジェクトファイル <code>test_2.o</code> を gcc を用いて 32 bit の実行ファイルに変換します。この変換には以下のコマンドを実行します。</li></ul><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>gcc -m32 -o test_2.out test_2.o
</code></pre></div><ul><li>これらの結果、<code>Hi!</code> という文字列を標準出力に書き込む実行ファイル <code>test_2.out</code> が作成されます。これは、以下のコマンドを実行することで確認することができます。</li></ul><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>./test_2.out
Hi!
</code></pre></div><ul><li>こうして、アセンブリ言語を書くことで <code>write</code> システムコールを呼び出し、標準出力に文字列を書き込むことができました。これは、1 で実装した C 言語のプログラムをアセンブリ言語で書き換えたものであるとも言えます。</li></ul><hr><ul><li><p>最後に、3 について検証したいと思います。</p></li><li><p>まず、ベースとなる C 言語のプログラム <code>test_3.c</code> を以下のように実装します。ここでは、<code>#include　&lt;stdio.h></code> を書かず、標準出力をするためのロジックである <code>void hi(char *string, int len)</code> は <code>test_3.asm</code> で実装します。</p></li></ul><div class=highlight><pre class=chroma><code class=language-c data-lang=c><span class=kt>void</span> <span class=nf>hi</span><span class=p>(</span><span class=kt>char</span> <span class=o>*</span><span class=n>string</span><span class=p>,</span> <span class=kt>int</span> <span class=n>len</span><span class=p>);</span>

<span class=kt>int</span> <span class=nf>main</span> <span class=p>()</span> <span class=p>{</span>
    <span class=kt>char</span> <span class=o>*</span><span class=n>string</span> <span class=o>=</span> <span class=s>&#34;Hi!</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>;</span>
    <span class=n>hi</span><span class=p>(</span><span class=n>string</span><span class=p>,</span> <span class=mi>4</span><span class=p>);</span>
    <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
<span class=p>}</span>
</code></pre></div><ul><li>実装した C 言語のプログラム <code>test_3.c</code> を以下のコマンドでオブジェクトファイル <code>test_3.o</code> を作成します。後で、アセンブリ言語で書いたプログラムから生成したオブジェクトファイルとリンクさせます。</li></ul><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>gcc -m32 -o test_3.o -c test_3.c
</code></pre></div><ul><li>次に、C 言語のプログラムから呼び出される関数 <code>hi</code> を <code>test_3.asm</code> に記述します。関数名が <code>hi</code> で、第一引数に文字列を第二引数にその文字列の長さを受け取ります。そして、受け取った文字列を標準出力に出力する関数です。基本的には 2 で実装したアセンブリをベースにしています。しかし、1 点だけ注意しないといけない点があります。それは、関数 <code>hi</code> の引数の値をスタックからレジスタにロードする必要があることです。2 では、標準出力する文字列とその長さをレジスタに直書きしていました。そのため、今回は <code>mov ecx, [esp+4]</code> や <code>mov edx, [esp+8]</code> の命令を使用してスタックの値をレジスタにロードします。これらの点に留意して実装したプログラムが以下になります。</li></ul><div class=highlight><pre class=chroma><code class=language-asm data-lang=asm><span class=nf>bits</span> <span class=mi>32</span>

<span class=nf>global</span> <span class=no>hi</span>

<span class=nl>hi:</span>
  <span class=nf>mov</span> <span class=no>eax</span><span class=p>,</span> <span class=mi>0x4</span>
  <span class=nf>mov</span> <span class=no>ebx</span><span class=p>,</span> <span class=mi>0x1</span>
  <span class=nf>mov</span> <span class=no>ecx</span><span class=p>,</span> <span class=p>[</span><span class=no>esp</span><span class=err>+</span><span class=mi>4</span><span class=p>]</span>
  <span class=nf>mov</span> <span class=no>edx</span><span class=p>,</span> <span class=p>[</span><span class=no>esp</span><span class=err>+</span><span class=mi>8</span><span class=p>]</span>
  <span class=nf>int</span> <span class=mi>0x80</span>
  <span class=nf>add</span> <span class=no>esp</span><span class=p>,</span> <span class=mi>0x4</span>
  <span class=nf>ret</span>
</code></pre></div><ul><li>実装したアセンブリ言語のプログラム <code>test_3.asm</code> から <a href=https://www.nasm.us/>nasm</a> コマンドでオブジェクトファイル <code>syscall_test_3.o</code> を作成します。</li></ul><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>nasm -f elf32 -o syscall_test_3.o test_3.asm
</code></pre></div><ul><li>ここまでで作成された 2 つのオブジェクトファイルを以下のコマンドでリンクして実行ファイル <code>test_3.out</code> を作成します。</li></ul><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>gcc -m32 -o test_3.out test_3.o syscall_test_3.o
</code></pre></div><ul><li>最終的に作成された実行ファイル <code>test_3.out</code> を実行すると、<code>Hi!</code> の文字列が出力されます。</li></ul><div class=highlight><pre class=chroma><code class=language-bash data-lang=bash>./test_3.out
Hi!
</code></pre></div><ul><li>こうして、アセンブリ言語で <a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/write.2.html>write</a> システムコールを呼び出し、標準出力に文字列を出力させる関数を実装し、その関数を C 言語で書いたプログラムから呼び出すことができました。ちなみに、アセンブリのプログラムが上手く動作しないときは、<a href=https://man7.org/linux/man-pages/man1/strace.1.html>strace</a> コマンドを使って、<a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/write.2.html>write</a> システムコールの引数に渡されている引数を確認してデバッグを行っていました。</li></ul><h2 id=結果と結論>結果と結論</h2><ul><li>以上の調査と検証の結果より、<a href=https://linuxjm.osdn.jp/html/LDP_man-pages/man2/write.2.html>write</a> システムコールにおけるシステムコール番号とシステムコールが対応関係を明らかにしました。C 言語やアセンブリ言語を使用した複数の視点を通して、検証することができて楽しかったです。この記事を推敲している段階で、似たようなことを書かれている <a href=https://www.linkedin.com/pulse/%E9%AD%85%E5%8A%9B%E7%9A%84%E3%81%AAlinux%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%82%B3%E3%83%BC%E3%83%AB%E3%81%AE%E4%B8%96%E7%95%8C-takao-shimizu/>魅力的なLinuxシステムコールの世界</a> という記事を見つけました。見つけた時は少し残念な気がしましたが、記事の方向性は悪くなかったと思いました🤞</li></ul><h2 id=参考>参考</h2><ul><li><p><a href=https://searchman.info/tips/1090.html>grepでファイル内を検索しよう</a></p></li><li><p><a href=https://www.amazon.co.jp/%E3%81%AF%E3%81%98%E3%82%81%E3%81%A6%E5%AD%A6%E3%81%B6%E3%83%90%E3%82%A4%E3%83%8A%E3%83%AA%E8%A7%A3%E6%9E%90-%E4%B8%8D%E6%AD%A3%E3%81%AA%E3%82%B3%E3%83%BC%E3%83%89%E3%81%8B%E3%82%89%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%82%92%E5%AE%88%E3%82%8B%E3%82%B5%E3%82%A4%E3%83%90%E3%83%BC%E3%82%BB%E3%82%AD%E3%83%A5%E3%83%AA%E3%83%86%E3%82%A3%E6%8A%80%E8%A1%93-OnDeck-Books%EF%BC%88NextPublishing%EF%BC%89-%E5%B0%8F%E6%9E%97-%E4%BD%90%E4%BF%9D-ebook/dp/B084R85269>はじめて学ぶバイナリ解析　不正なコードからコンピュータを守るサイバーセキュリティ技術</a></p></li><li><p><a href=https://github.com/dilmnqvovpnmlib/BinaryAnalysisBook/tree/main/s6>dilmnqvovpnmlib/BinaryAnalysisBook</a></p></li><li><p><a href=https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md>Linux System Call Table</a></p></li><li><p><a href=https://github.com/dilmnqvovpnmlib/LowLevelProgramming/tree/main/log/20210508>2021/05/08</a></p></li><li><p><a href=https://www.linkedin.com/pulse/%E9%AD%85%E5%8A%9B%E7%9A%84%E3%81%AAlinux%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E3%82%B3%E3%83%BC%E3%83%AB%E3%81%AE%E4%B8%96%E7%95%8C-takao-shimizu/>魅力的なLinuxシステムコールの世界</a></p></li></ul></article><nav class="no-print post-nav"><a class=prev-post href=https://hakiwata.jp/post/20210615/><img class=icon-text src=https://hakiwata.jp/img/prev.svg>5 月の振り返り</a>
<a class=next-post href=https://hakiwata.jp/post/20210622/>このブログを運用する目的<img class=icon-text src=https://hakiwata.jp/img/next.svg></a></nav><hr class=sep></main><footer class="container no-print"><div class=u-footer><a href=https://github.com/dilmnqvovpnmlib><img class=icon-social src=https://hakiwata.jp/img/github.svg alt=Github></a>
<a href=https://twitter.com/bilmnpvovqnmlid><img class=icon-social src=https://hakiwata.jp/img/twitter.svg alt=Twitter></a>
<a href=https://hakiwata.jp/index.xml target=_blank><img class=icon-social src=https://hakiwata.jp/img/feed.svg alt=Feed></a><p>&copy; 2021 haKiwata</p><a href=#brand><img class=icon-text src=https://hakiwata.jp/img/toup.svg alt="To Up">
<span>Back to Up</span></a></div></footer></body></html>