<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on haKiwata</title><link>https://hakiwata.jp/post/</link><description>Recent content in Blog on haKiwata</description><generator>Hugo -- gohugo.io</generator><copyright>&amp;copy; 2021 haKiwata</copyright><lastBuildDate>Fri, 30 Apr 2021 00:00:00 +0800</lastBuildDate><atom:link href="https://hakiwata.jp/post/index.xml" rel="self" type="application/rss+xml"/><item><title>CyberAgent のコンテナ技術に関する勉強会に参加してきた</title><link>https://hakiwata.jp/post/20211124/</link><pubDate>Tue, 30 Nov 2021 18:35:39 +0000</pubDate><guid>https://hakiwata.jp/post/20211124/</guid><description>概要 先日 2021/11/24 に CyberAgent が主催するCA 1Day Youth Boot Camp バックエンド/インフラエンジニア編：現場で使うコンテナ技術、Kubernetes＆コンテナ入門と言う勉強会に参加してきました。これは、CyberAgent での社内の研修を 1 日体験できるイベントでした。今回は、その参加記を書きたいと思います。 参加したキッカケ 普段から Docker や Kubenetes を活用して趣味のプログラムや研究のコードを書いたりしています。しかし、これまでこれらの技術はほとんど独学で勉強をしてきました。そのため、自分の理解のレベル感が客観的に把握したことがありませんでした。また、最近 ES を書いたり外部の勉強会に参加するといった活動をしていませんでした。そんな時に、Twitter でたまたまこのイベントを見つけ、久しぶりにこういったチャンスに挑んでみたいと思い参加してみました。 学んだこと Kubernetes の基礎編 で Kubernetes の基本的なコンセプトや原理を復習できました。 コンテナレジストリのミラーリポジトリに mirror.gcr.io 活用すると、Docker Hub のレート制限を抑えることができることを初めて知りました。 Kubernetes in Docker (kind) と言う Docker コンテナのノードを使ってローカルに Kubernetes クラスタを実行するためのツールを初めて知りました。 kubectl edit コマンドや kubectl run コマンドを始めて使いました。 Kubernetes 内の Pod からしかアクセスできない Pod に対して、busybox と kubectl run コマンドを用いたデバッグを初めて知りました。 感想 学んだことに書いたように、知らなかったことをたくさん知るキッカケになりました。また、特に Kubernetes の研修に関しては、CyberAgentHack/one-day-youth-bootcamp-ciu にある演習問題を解いて手を動かす時間も設けられていたので、とても楽しかったです！ (演習問題は簡単でした。) しかし、この勉強会で学んだことと実際に現場で必要な知識や技術力にはかなり乖離があると感じました。そのため、Kubernetes を実際に運用するレベルのアプリケーションの実装を検討してみたいと思いました🤞 参考 コンテナ技術入門 Kubernetes の基礎編 CyberAgentHack/one-day-youth-bootcamp-ciu Container Registry の Docker Hub ミラーの使用 kind busybox どのリクエストにも決まったレスポンスを返す、http-echoサーバー</description></item><item><title>このブログで使用した技術について</title><link>https://hakiwata.jp/post/20211110/</link><pubDate>Wed, 10 Nov 2021 11:17:18 +0000</pubDate><guid>https://hakiwata.jp/post/20211110/</guid><description>概要 こんにちは！このブログを立ち上げてから約半年が経ちました。カスタマイズ性が高く簡単に運用できています。また、自分の書いた記事が積み重なっていく様子が可視化されるのが単純に嬉しいので、定期的なアウトプットに役立っています。そこで、今回はこのブログを作成するにあたって使用した技術などについて改めて振り返りたいと思います。 背景 このブログには様々な機能を加えたりして工夫を行っています。具体的には以下の 8 つが挙げられます。過去にブログにまとめた記事もあるので、それ以外を補足しつつどう工夫してこのブログが成り立っているかについて説明したいと思います。 Hugo と GitHub Pages を用いて開発 自動でデプロイするフローの導入 (CI/CD の構築) テンプレートを修正する 他のリポジトリとの連携 開発環境の Docker 化 バグの調査 Google Analytics の導入 OGP の作成 まず、1 に関して補足して説明します。このブログ (ポートフォリオ) は第三世代になります。第一世代は React + GitHub Pages のシンプルな構成で運用していました。あまり頻繁に更新するものでもなかったのですが、自動デプロイのパイプラインは構築していました。リポジトリは dilmnqvovpnmlib になります。第二世代は、React + Django + EC2 で運用していました。これは、単純にフロントエンドとバックエンドを分割させた形のアプリケーションを実装したかったという意図もあり、このような構成となりました。各アプリケーションは Docker と docker-compose を使用して Nginx のコンテナを経由して通信します。リポジトリは hk-41 になります。これらの 2 つのポートフォリオには単純に自己紹介をするページしかなく、ブログを投稿する機能がありませんでした。そこで、楽に運用でき拡張性も高い Hugo と GitHub Pages で新しく作り直したのがこのブログでした。
次に、2 に関して補足して説明します。main ブランチ に About と Post と Scraps の修正コードを push すると、GitHub Actions 上で設定したパイプラインが走ります。そうすると、ソースコードをビルドし自動でデプロイしてくれるようなフローを構築しています。この結果、デプロイのコマンドを逐一思い出す必要がなく、属人性を省いたデプロイができて嬉しいです。このブログは基本的には自分しか操作しない想定で作られています。そのため、プルリクを作成し、複数人の Approve を得てからデプロイを行うといった実務的なフローは構築していません。</description></item><item><title>ゼロからのOS自作入門を読んで
OS を実装してみた</title><link>https://hakiwata.jp/post/20211018/</link><pubDate>Sun, 17 Oct 2021 19:29:55 +0000</pubDate><guid>https://hakiwata.jp/post/20211018/</guid><description>概要 こんにちは！今年の 8 月中旬からゼロからのOS自作入門を読んで紹介されている OS を一通り写経して作り上げてみました。そこで、今回はこの本を読むまでに何をしていたかを振り返りつつ、読もうと思ったきっかけや感想などを残したいと思います。 きっかけ 今年度で学生生活が最後で時間に余裕がある内に、コンピュータや OS について詳しくなりたいと思っていました。自分は普段から Ubuntu 18.04 を使っているのですが、低レイヤや Linux に詳しくありません。そのため、まず初めの取っ掛かりとして低レイヤ周りの本や資料を少しずつ読んだりしていました。例えば以下が挙げられます。
[試して理解]Linuxのしくみ ~実験と図解で学ぶOSとハードウェアの基礎知識 コンピュータシステムの理論と実装 ―モダンなコンピュータの作り方 低レイヤを知りたい人のためのCコンパイラ作成入門 ふつうのLinuxプログラミング 第2版 Linuxの仕組みから学べるgccプログラミングの王道 基礎からわかるTCP/IP ネットワーク実験プログラミング（第2版） Hacking: 美しき策謀 第2版 ―脆弱性攻撃の理論と実際 ハロー“Hello, World” OSと標準ライブラリのシゴトとしくみ このように Linux や低レイヤに興味がありつつ、大学の先輩が Linux Kernel にコントリビュートし楽しそうにしている様子を見たり、研究室の隣の同期がこの本を読み切ったりしていて、今始めることがチャンスだと思い、思い切って初めてみました。
感想 OS を一から作り上げる行為は、低レイヤの総合格闘技感があり、非常に楽しかったです。この本を通して個人的に特に面白かった箇所を抜粋して挙げていきます。
一番初めの Hello World を出力できた時 C++ で実装できないロジックをアセンブリ言語で実装した時 割り込みを実装し、メッセージを送受信できた時 コンテキストスイッチの実装を知った時 Priority Queue を使ってタスクに優先度を付け、タスクを Sleep/Running できるように実装した時 初めてシステムコールを実装した時 ファイルの書き込みファイルディスクリプタで抽象化した時 ページフォルトを活用してデマンドページングを実装した時 実装のバグを調査するために printk や Log でデバッグをたくさんした時 この本を読んだ研究室の同期と OS の機能に関する実装に関する議論ができたこと また、細かい日記に関しては以下に記述しました。全く書いていない箇所もあればデバッグが辛かった様子を書いたりしていて、内容に関してはまちまちです。</description></item><item><title>自作 OS のリポジトリの README.md を自動更新する</title><link>https://hakiwata.jp/post/20210911/</link><pubDate>Fri, 10 Sep 2021 15:50:53 +0000</pubDate><guid>https://hakiwata.jp/post/20210911/</guid><description>概要 こんにちは！先月から 自作 OS に取り組んでいます。その進捗を綴った日記は 自作 OS 日記 にあり、日記にはその日までに出来上がった OS の挙動を記録した GIF を載せています。これまでは、この日記を更新すると、手動で 自作 OS のリポジトリの README.md に最新の OS GIF のリンクを貼り付けていました。ですが、最近、その作業がすごく面倒臭くなってきました。そこで、今回は 自作 OS 日記 を更新すると、 自作 OS のリポジトリの README.md も同時にアップデートされるように行った自動化の記録について書き残したいと思います。 方法 今回の自動化では、以下のようなパイプラインを構築しました。 一番のポイントは、リポジトリを跨いだ GitHub Actions のワークフローの連携です。これを実現するために、Repository Dispatch というアクションを使用しました。このアクションを用いて、自作 OS 日記 のコンテンツ配下のみが更新されると、workflow が走るような設計になっています。
このアクションでは、client-payload というペイロードを活用すると、通知先にデータを送信することができます。いわゆる HTTP の POST メソッドのようなことができます。したがって、日記を更新した段階で最新の GIF のリンクを取得できれば、このパラメータを活用して 自作 OS リポジトリにその最新のファイル名を通知することができます。今回の自動化の流れでは、この最新の GIF のファイル名を Python と GitHub の API を用いて取得します。一番初めは、このやり方で実装を考えていたのですが、日記側のリポジトリと自作 OS 側のリポジトリの両方で Python のスクリプトを用意する必要がありました。これでは、双方のリポジトリに README.</description></item><item><title>自作 OS 日記 (3)</title><link>https://hakiwata.jp/post/20210901/</link><pubDate>Wed, 01 Sep 2021 19:11:00 +0000</pubDate><guid>https://hakiwata.jp/post/20210901/</guid><description>概要 こんにちは！前回に引き続き自作 OS 日記を付けたいと思います。このエントリでは 21 ~ 30 章までの記録を残したいと思います。 日記 2021 年 9 月 25 日 osbook_day21a IST を設定しました！ osbook_day21b rpn コマンド で引き算した結果をターミナルに出力するためのシステムコールを実装した。だいぶ身近な箇所の実装にまで辿り着いてさらに楽しくなってきた。 2021 年 9 月 26 日 osbook_day21c 終了のシステムコールを実装しました！この実装により、rpn コマンドで足し算や引き算をした結果を出力し、制御をターミナルに戻すことができます。 今回は、解説されているプログラムをアプリケーション側から写経していきました。つまり、apps/rpn/rpn.cpp の main 関数 内で SyscallExit を呼び出すことから実装を始めました。これは、前節ではアセンブリから実装を始めたので、視点を変えたかったためです。
この節を実装して特に感じたことがあります。それは、節によっては説明が前後するため、紹介されているプログラムを読んで直後の解説を読んでもわけがわからないときが多々あることです。自分は紹介されているプログラムが自分で理解できる時は、プログラムを読んで自分なりの解釈を作ってから直後に書かれている解説を読むようにしています。しかし、プログラムを読んでなぜこの実装にしたのかの意図が全くわからず、直後の解説を読んでも特に触れられていない時があります。その時は、その実装の解釈に対してめちゃくちゃ悩み、妥協して読み進めるしかありません。そして、読み進めると、後の方のページでそのプログラムに対する解説を見つけると、何やねんと思ったりすることもありました。紙面や解説の都合上こうなるのはしょうがないと思うのですが、おいってなります。そのため、自分のこの本の読み方を改めつつ、もっと多くの知識を付けたいと思いました。
2021 年 9 月 27 日 osbook_day21d アプリケーションが増えてきたので、アプリケーションのリファクタリングを行いました。UI に特に変更はありません。 osbook_day21e ウィンドウを開くシステムコールを実装しました。 osbook_day21f 前節で実装したシステムコールに機能を加え、開いたウィンドウに文字を表示させました。 2021 年 9 月 28 日 osbook_day22a exit システムコール を実装しました。これまで SyscallExit と記述していた実装を exit に書き換えて C の標準ライブラリを使うように修正しました。しかし、以下のように _exit が定義されていないというエラ−が出ます。そこで、エラーログに書かれているように apps/newlib_support.</description></item><item><title>自作 OS 日記 (2)</title><link>https://hakiwata.jp/post/20210831/</link><pubDate>Mon, 30 Aug 2021 19:11:00 +0000</pubDate><guid>https://hakiwata.jp/post/20210831/</guid><description>概要 こんにちは！前回に引き続き自作 OS 日記を付けたいと思います。このエントリでは 11 ~ 20 章までの記録を残したいと思います。 日記 2021 年 9 月 1 日 osbook_day11a main 関数のリファクタリングを行いました。main 関数が大きすぎて大変でした。見た目の挙動は osbook_day10g と変わりません。 osbook_day11b 周期的に割り込むタイマを実装しました。一定のカウントが刻まれると、割り込みが入り、背景に文字列が表示されます。 osbook_day11c 前節よりも短い周期で割り込みを行わせ、その割り込み回数を計算します。 2021 年 9 月 2 日 osbook_day11d 複数のタイマを作成し、それらからのタイムアウト通知を受け取ることができるように修正しました。 osbook_day11e Kernel で Root System Description Pointer を取得できるように修正しました。これは、後々 IO ポート番号を求めるのに役立ちます。 osbook_day12a IO ポート番号を求めるのに必要な FADT というテーブルのデータを取得する実装を行いました。UI に変化はありません。 2021 年 9 月 3 日 osbook_day12b ACPI PM タイマ (基準となる軸で、fadt-&amp;gt;pm_tmr_blk から求められる。) を使用して Local APIC タイマの 1 カウントが何秒なのかを計測します。 osbook_day12c osbook_day12d osbook_day12e osbook_day12f 2021 年 9 月 4 日 osbook_day13a 協調的マルチタスクの機能を実装しました！ osbook_day13b プリミティブなプリエンプティブマルチタスクの機能を実装しました！特にコンテキストスイッチの自動化を行いました。 osbook_day13c マルチタスクが実装できるかを検証しました。Hello Window と TaskB Window のカウンタが 1 秒おきに切り替わっていることがわかります。しかし、カウンタは 2 秒間分のカウントを刻んでいます。 osbook_day13d マルチタスクを管理するための TaskManager を実装しました。タスクを増やせば増やすほどマウスがカクつく問題が生じたので、次章以降で修正していきたいと思います！ 2021 年 9 月 5 日 osbook_day14a ランキューを作成して実行可能状態にあるタスクを保持する。処理が完了したタスクをランキューから取り出し Sleep させ、CPU が割り当てられないような機能を実装する。この節では、キーボードからの入力でタスクを Sleep させるか Wakeup させるかを適宜切り替える。 osbook_day14b osbook_day14c osbook_day14d 2021 年 9 月 6 日 osbook_day15a ウィンドウの描画をメインスレッドで行うようにリファクタリングを行いました！これまでは TaskB とメインタスクの両方で画面の再描画を行っていました。しかし、それが原因でデータをの競合が発生し、ウィンドウを動かすと、そのゴミが残ってしまっていました。 osbook_day15b ウィンドウにアクティブ/非アクティブの機能を追加しました！ この節通りにプログラムを実装すると、実行後すぐに TaskB のウィンドウが消えてしまいます。状況を切り分けてトラブルシューティングすると、main.</description></item><item><title>自作 OS 日記 (1)</title><link>https://hakiwata.jp/post/20210830/</link><pubDate>Sun, 29 Aug 2021 19:11:00 +0000</pubDate><guid>https://hakiwata.jp/post/20210830/</guid><description>概要 こんにちは！最近、研究室の隣の同期に影響されて自作 OS を始めました。そこで、今回は自作 OS が成長していく様子を日記としてこの記事に残したいと思います。このエントリでは 1 ~ 10 章までの記録を残したいと思います。 日記 2021 年 8 月 13 日 osbook_day01 自作 OS を始めました！名前は HonOS です！名前の由来は櫻坂46 の田村保乃ちゃんのあだ名の「ほのす」から付けました。 2021 年 8 月 28 日 osbook_day09b osbook_day09c osbook_day09d 2021 年 8 月 29 日 osbook_day09e 2021 年 8 月 29 日 osbook_day10a osbook_day10b-invalid FrameBuffer::Copy の実装が間違っていたせいで表示がバグってしまいました。状況を切り分けつつバグを調査する過程が最高に楽しかったです。 osbook_day10b ウィンドウを表示することができました！ osbook_day10c Kernel の main 関数の for ループ回数を書き込んだウィンドウを表示することができました！ 2021 年 8 月 30 日 しかし、この記事を見た同期に表示されている色の挙動がおかしいと指摘されました。そこで、osbook_day10c に checkout し、正常系の挙動を確認してみました。そうすると、確かに正常系と比較すると、挙動がおかしかったので、バグを調査し修正しました。原因は constexpr PixelColor ToColor(uint32_t c); の色のビットシフトが逆になっていたことでした。だいぶ画面がチカチカしていますが、そのリファクタリングは次節以降でできればと思っています！ 2021 年 8 月 31 日 osbook_day10d osbook_day10e この節では、バックバッファに描画を行った後に、バックバッファをフレームバッファに転送を行います。こうして転送を行うことで、マウスカーソルが表示されない期間を完全になくし、カウンタにマウスを重ねた時のチラツキをなくすことができます。 参考 ゼロからOS自作入門 10章 【OpenGLでゲームを作る】ダブルバッファリングとは ダブルバッファリング 【double buffering】 描画処理について osbook_day10f USB ドライバからデータを取り出すプログラムは、マウスのボタンが押されたかとマウスがどれだけ移動したかの変位を取得できる機能のものでした。しかし、なぜかドライバから Kernel にそれらのデータが渡されませんでした。make clean や rm kernel.</description></item><item><title>自作ブログの開発環境を
Docker で移行した</title><link>https://hakiwata.jp/post/20210628/</link><pubDate>Sat, 26 Jun 2021 20:39:56 +0000</pubDate><guid>https://hakiwata.jp/post/20210628/</guid><description>概要 こんにちは！前回は、Hugo で Markdown が上手く parse されない原因を調査してみたという記事を書きました。この際、開発環境を Docker で作ることで、 Hugo のバージョンを上げました。そこで今回は、開発環境の移行で行ったことについての記録を残したいと思います。 背景と目的 もともとはホスト OS に Hugo のバイナリをインストールして開発環境を構築していました。しかし、この開発方法だと前回の記事のように Hugo のバイナリのバージョンを上げたいと思った時にすぐにバージョンアップをすることが面倒臭いです。そのため、今回は make コマンド と Docker を使用して開発の体験を上げ、Hugo のバージョンの変更に対応しやすいように開発環境を作り直しました。 方法 以下の 3 つの機能を make コマンド でまとめることが最終目標でした。 Hugo のバージョン管理をしやすくすること 開発用サーバを起動するコマンドを作ること 新規コンテンツを作成するコマンドを作ること 今回、実際に実装した Makefile は以下のようになりました。VERSION 変数 で Hugo のバージョン管理をしやすくしています。また、make server コマンドで開発用サーバが起動し、make new D=&amp;quot;directory name&amp;quot; で新規コンテンツのセットアップを行うようにしました。 VERSION=0.83.1 PORT=1313 OLD_VERSION=0.65.3 $(eval USER_ID := $(shell id -u $(USER))) $(eval GROUP_ID := $(shell id -g $(USER))) .</description></item><item><title>Hugo で Markdown が上手く Parse されない原因を調査してみた</title><link>https://hakiwata.jp/post/20210624/</link><pubDate>Tue, 22 Jun 2021 13:08:38 +0000</pubDate><guid>https://hakiwata.jp/post/20210624/</guid><description>概要 こんにちは！前々回の記事で Table を表現する Markdown が上手く表示されないバグにハマってしまいました。今回は、そのバグをどのように調査して解決したかについての記録を残したいと思います。 背景 前々回の記事で CPU のアーキテクチャとレジスタの関係を表す表を記述しました。その Markdown の抜粋は以下になります。 | arch | syscall NR | | :---: | :---: | | x86 | eax | このように記述すると、表の中の文字列が中央揃えに表示される想定でした。しかし、表示結果は以下のように左揃えになっています。 これは、想定していた挙動と違っていました。HTML で言うところの、table タグ の align 属性 が適用されていません。そのため、この Markdown の記述で表の文字列が中央揃えになるようにトラブルシューティングとその改善をしたいと思います。 目的 Table の中央揃えと右揃えを表す Markdown が上手く Parse されない原因を明らかにし、改善するプロセスを振り返ることがこの記事の目的です。まず、この原因が Hugo 側にあるのか、あるいは Markdwon Parser に原因があるのか、あるいはそれ以外なのかを調査します。そしてその調査結果に基づいて不具合を修正します。 調査プロセスと解決方法 この問題の原因は大きく 2 つに分けられます。Hugo に問題があるケースと Markdown Parser に問題があるケースです。そこで、まず、Hugo が採用している Markdown Parser 側からの調査を行いました。</description></item><item><title>このブログを運用する目的</title><link>https://hakiwata.jp/post/20210622/</link><pubDate>Mon, 21 Jun 2021 14:53:48 +0000</pubDate><guid>https://hakiwata.jp/post/20210622/</guid><description>概要 こんにちは！このブログを作成してから早 2 ヶ月が経とうとしています。また、この記事で 10 記事目となる節目でもあります。そこで今回はこのブログを作成した意図やブログを書く目的について改めて考えたいと思います。 背景 自分はそもそも文章を書くことが得意ではありません。そもそも言語化や人に何かを説明するのが苦手です。これは、学部の卒論を書いたときや就活中に痛感しました。Qiita や Hatena Blog を使って文章を書く練習しようと試みたこともありましたが、継続的に文章を書くことができませんでした。 また、記憶力が悪く、例えば何か問題を解決した時のプロセスを詳しく思い出すことが苦手です。そこで、この自作ブログを運用して育てることを通して、これらの苦手なことを苦手に感じないレベルまで引き上げればと考えています。そして、それに乗じて他人に目に晒すアウトプットができればと考えています。 ブログを書くに当たっての目的とルール ブログを書く目的は以下のように考えています。 言語化能力を上げる。 一定のフォーマットに従って論理的に素早く文章を書く練習をする。 思考プロセスを論理的に振り返る練習をする。 アウトプットを意識してインプットする場として存在させる。 人との会話における引き出しにする。 そして、ブログを書くに当たって自分なりに決めたルールは以下のように考えています。 月 1 件は何か記事を書くこと。数をこなすことを目的にしない。 論理的に正しいわかりやすい文章を書くこと。 技術や勉強したことをアウトプットすること。 特に厳しいルールは課していません。それは、継続的に何かをアウトプットする意識が大事だと考えているからです。今取り組んでいることがブログのネタにならないか、あるいは、今考えているとを拡張すればネタにできないかとアウトプット前提とした普段からの意識付けが何よりも大切だと思っています。
最近では、この意識付けのおかげで、技術的な問題を解決した際に、その解決における思考プロセスを意識的に振り返る習慣を少しずつ付けることができています。こうして、ブログを書くことで良い傾向が日に日に現れています。
現時点でブログを書き続けられている理由と最終目標 これまでは、Qiita や Hatena Blog を使ってブログを書き続けることができなかったのに、自作ブログではブログを書き続けられるようになったのは、飛躍がある気がします。これまでできなかったことができるようになるのには理由があるはずです。これはおそらく、精神的な余裕がある中で自由に時間を過ごせる権利が現時点であるからではと考えています。そのため、社会人になったらブログを書き続けられないかもしれません。しかし、それまでに毎月何件かはブログを書かないと気持ち悪くなるぐらいに、習慣化できればと考えています。 最後に 自前でブログを作るのは面倒臭かったです。しかし、今ではこのブログを育てて行きたいと思えているので、作って良かったです。気負いせずに継続的にブログを書くことで、論理的な文章を書く力を上げていきます🤞</description></item><item><title>システムコール番号を使って write システムコールを呼び出す</title><link>https://hakiwata.jp/post/20210618/</link><pubDate>Fri, 18 Jun 2021 02:21:38 +0900</pubDate><guid>https://hakiwata.jp/post/20210618/</guid><description>概要 こんにちは！最近、低レイヤ寄りの実装に興味があり、Linux Kernel のシステムコール周りのソースコードを読む機会がありました。その際に、システムコールには、対応するシステムコール番号があるのを知りました。そこで、今回は C 言語やアセンブリ言語を書くことを通して、write システムコールにおけるシステムコール番号とシステムコールの関係性について調査してみたいと思います。 背景と目的 あるとき、socket システムコールは第三引数の protocol に応じてどのような処理が行われているかが気になったことがありました。その際、socket システムコールのプログラムを Linux Kernel のソースコードから紐解く静的解析を行いました。静的解析でプログラムを追っていくと、write システムコールが呼び出されていることに気づきました。このことがキッカケで、一番プリミティブで親近感のある write システムコールの実装やシステムコール番号との関係性に興味を持ちました。
そこで、今回は検証プログラムを実装することを通して、write システムコールにおけるシステムコール番号とシステムコールの関係性を明らかにします。
方法 以下の 1 と 2 と 3 の順序で検証を行います。 まず、syscall 関数とシステムコール番号を使用して標準出力に文字列を出力する C 言語のプログラムを実装します。これにより、システムコール番号とシステムコールの対応関係に対する理解を深めます。
次に、アセンブリ言語単体でシステムコールを呼び出すプログラムを実装します。これにより、システムコールを呼び出す際に必要な引数をスタックに詰んで、システムコールを呼び出す流れを確認します。
最後に、アセンブリ言語でシステムコールを呼び出し、標準出力に文字列を出力させる関数を実装し、その関数を C 言語で書いたプログラムから呼び出します。こうして、C 言語で書いたプログラムとアセンブリ言語で書いたプログラムの関係性を確認します。ただし、ここで取り扱うアセンブリ言語のプログラムは 32 bit の実行ファイルを作成するためのプログラムです。
それでは、1 を検証したいと思います。 まず、syscall 関数のマニュアルを確認すると、以下のような記述がありました。 NAME syscall - indirect system call SYNOPSIS #define _GNU_SOURCE /* See feature_test_macros(7) */ #include &amp;lt;unistd.</description></item><item><title>5 月の振り返り</title><link>https://hakiwata.jp/post/20210615/</link><pubDate>Tue, 15 Jun 2021 00:34:14 +0900</pubDate><guid>https://hakiwata.jp/post/20210615/</guid><description>概要 こんにちは！振り返りでは 1 月 ~ 4 月に勉強したことを振り返りました。しかし、6 月に入っても未だに 5 月に勉強したことをブログに書いて振り返ることができていませんでした。そこで、今回は 5 月に勉強したことを毎日メモしているノートを参考にザックリまとめたいと思います。 勉強したこと ここには、趣味で勉強したことと大学院生活に関するに分けて書きました。 趣味に関すること C 言語で Exercism を 2 問解きました。 自作エディタ keditor を実装しました。 参考にする自作エディタ kilo のコードリーディングを行いました。 また、Build Your Own Text Editor を読みました。これは kilo の解説記事です。そのため、コードリーディングにおける自分の解釈と照らし合わせながら読みました。この際に、必要なライブラリや処理の調査と検証をログに残しつつ行いました。 上のプロセスを経て keditor を実装しました。 Linux のシステムコールの静的解析を行いました。 この内容はブログにしようと思いながら時間が経ってしまっています。今月中には書きたいと考えています。 C 言語で #include &amp;lt;stdio.h&amp;gt; を行わずに Hello World を標準出力に表示させました。 この内容はブログにしようと思いながら時間が経ってしまっています。今月中には書きたいと考えています。 基礎からわかるTCP/IP ネットワーク実験プログラミング（第2版） を読みました。 詳しくは Network Programming の基礎を学んだ に書きました。 ProjectEuler を 24 問解きました。 Heroku 上に Flask で作成した REST API をデプロイしました。 プログラミングの基礎を読み始めました。 ブログを 3 本書きました。 研究に関すること 研究の進捗報告を 1 回しました。 大学院の講義のレポートを何本か書きました。 感想 こうして振り返ってみると、異常に多くのことをこなしていてビックリしました。もちろん GW があったのが一つの理由ではあると思います。毎日つけているノートを振り返ると、そういやこんなことしてたなぁと思い返したり、やり残していることに気づいたりと、色々と振り返ることができて良かったです。一方で今月はあまり進んでいない気もしてきました。今月も折り返していますので、残りの後半も頑張りたいと思います🤞 参考 Exercism keditor BinaryAnalysisBook/s6 kiso_tcp flask-api</description></item><item><title>.gitconfig を使って untracked files のみを退避させる</title><link>https://hakiwata.jp/post/20210613/</link><pubDate>Sun, 13 Jun 2021 06:13:26 +0900</pubDate><guid>https://hakiwata.jp/post/20210613/</guid><description>概要 自分で運用しているブログサイトは git を用いて管理しています。新しい記事を作成する際に、untracked files のみを git stash して、退避させたいことがありました。しかし、git にはデフォルトで untracked files のみを退避させるコマンドは無いそうです。そこで、今回は .gitconfig を使用して工夫したことについての記録を残したいと思います。 背景と目的 新しい記事を作成するために hugo new コマンドで記事の雛形を作成します。過去に書いた記事を参考にしつつ新しい記事を書いていると、過去の記事にタイポを見つけて修正したくなることや、言い回しを変えたくなる時があります。その内容を修正しつつ、一通り満足の行く新しい記事を書き終えると、hugo コマンドで修正したり作成したファイルを build を行った後に push する必要があります。しかし、修正した過去の記事と新規作成した記事の build を別々に行った後に push してコミットを分けたいと考えています。そのため、このようなケースでは一旦新規作成した記事を退避させて build を行い、push します。そして、その後に git stash pop で退避させた新規作成した記事を元に戻してから build を行い、push するようにします。
こうして untracked files のみを退避させたいのですが、このコマンドは毎回調べているイメージがありました。その調べている時間が無駄でもったいないと感じていました。そこで、今回はその無駄な手順を省くために .gitconfig を使用し、 untracked files のみを退避させるエイリアスを設定しました。また、.bashrc に記述していた git コマンドのエイリアスも .gitconfig に移して、設定ファイルの整理も行いました。
方法 untracked files のみを退避させる方法は How to git stash only untracked files?</description></item><item><title>Hugo のテンプレートを修正してみた</title><link>https://hakiwata.jp/post/20210611/</link><pubDate>Fri, 11 Jun 2021 17:37:01 +0900</pubDate><guid>https://hakiwata.jp/post/20210611/</guid><description>概要 こんにちは！自分の Web サイトは Hugo を用いて運用しています。これまでは、デフォルトの設定で特に大きく変更すること無く使用していました。しかし、表示するコンテンツを追加したいと思い、思い切ってテンプレートに修正を加えていくことにしました。今回は、その際に行った修正などについての記録を残したいと思います。 背景と目的 記事を新しく追加していくと、Latest Posts の記事から、メモ的なお気に入りの記事が埋もれてしまう問題点がありました。現状の設定では Latest Posts に表示される記事の数は 5 件です。そこで、トップページに Favorite Posts の項目を追加し、メモ的なお気に入りの記事を表示させるようにしました。 方法 上述の目的を成し遂げるために以下の 3 つのことを行いました。 archetypes/default.md の Front Matter Variables に favorite: false を追加します。このパラメータは Favorite Posts の箇所に記事を表示させるかのフラグです。 Favorite Posts に表示させたい記事の Front Matter Variables に favorite: true を追記します。 themes/manis-hugo-theme/layouts/index.html を修正します。favorite: true の記事をフィルタリングし、 Favorite Posts を表示するようなロジックを追加します。 3 に関しては Latest Post のプログラムと公式のドキュメントの Hugo の文法を参考に実装しました。特に、Nest where Clauses が参考になりました。 感想 実装したい機能から逆算して修正すべきファイルに当たりをつけて、リバースエンジニアリング的に機能を拡張できて楽しかったです。Hugo は Golang の機能を活用して実装されています。Golang や Hugo に詳しいわけではないのですが、公式ドキュメントを読んでいると Hugo の文法も少し知ることができました。こうして、なんとか実現したい機能を調査と検証を繰り返しながら実装できて良かったです。また少し技術力が上がった気がします。 参考 Front Matter Nest where Clauses hakiwata/issues/3</description></item><item><title>関数型プログラミングに入門した</title><link>https://hakiwata.jp/post/20210610/</link><pubDate>Thu, 10 Jun 2021 01:34:28 +0900</pubDate><guid>https://hakiwata.jp/post/20210610/</guid><description>概要 こんにちは！先月末から プログラミングの基礎 を読んでいました。普段は Python や C 言語でプログラムを書くことが多いのですが、この本を通して、関数型プログラミングに入門しました。丁度今日に読み終えたので、なぜ読み始めたのかや何を学んだかなどの記録を残したいと思います。 読み始めたきっかけと目的 この本を読もうと思ったきっかけは、関数型プログラミングを通して再帰の概念や多相型について学びたいと思ったからです。2, 3 年前までは競技プログラミングをしていたのですが、その時に再帰的なプログラムを書くのに苦手意識を感じていました。典型的な再帰の問題は解けるのですが、少し難しい応用的な問題が出ると、お手上げな状態でした。実務などで頻繁に使うイメージはないのですが、前々から苦手意識は潰しておきたいと思っていました。そのため、関数型プログラミング言語の OCaml を通して再帰的なデータ構造や多相型について学ぶことが、この本を読む目的でした。 学んだこと この本を通して学んだことを列挙します。 プログラムを書く際のデザインレシピとその実践 関数の目的と入出力の型を考える 関数のテストケース (具体例) を考える 関数のテンプレート (骨組み) を実装する 以上のことを基に関数の本体を実装する テストケースに従って関数をテストする 再帰的なプログラミング リスト自体が再帰的なデータ構造である 数学的帰納法をイメージするとわかりやすい リストを定義するには、要素とリストが必要なので、再帰的なデータ構造となる 関数の抽象化 多相型を使用したデータ構造 エラーハンドリング 紹介 ここでは、紹介されていたプログラムの中で、なるほど！と思ったプログラムについて紹介したいと思います。
接頭語のリストから全ての接頭語のリストを返す関数 prefix を実装することがこの章での目的です。例えば [1; 2; 3; 4] のリストを受け取ると、[[1]; [1; 2]; [1; 2; 3]; [1; 2; 3; 4]] を返す関数の実装です。</description></item><item><title>Network Programming の基礎を学んだ</title><link>https://hakiwata.jp/post/20210529/</link><pubDate>Sat, 29 May 2021 00:08:15 +0900</pubDate><guid>https://hakiwata.jp/post/20210529/</guid><description>概要 こんにちは！ゴールデンウィーク明けから 基礎からわかるTCP/IP ネットワーク実験プログラミング（第2版） を読んでいました。この本は マスタリングTCP/IP―入門編―(第6版) の著者の一人である 村山公保先生 が書かれた本です。丁度今日に読み終えたので、なぜ読み始めたのかや何を学んだかなどの記録を残したいと思います。 読み始めたきっかけと目的 この本を読もうと思ったきっかけは、システムプログラミングをしつつ、ネットワークプロトコル (Ethernet/ARP/IP/ICMP/TCP/UDP) を C 言語のプログラムレベルで理解したいと思ったからです。例えば TCP のヘッダの構造体は Ubuntu のどのパスに定義されていて、それを用いて、システムコールをどのように呼び出せば TCP のパケットを作って通信できるかなどです。大学/大学院の講義やマスタリングTCP/IP や普段の Web プログラミングを通して、基本的な通信の概念は知っていました。しかし、プロトコルをプログラムレベルでイメージできるほどは理解できていませんでした。そのため、ネットワークプロトコルの実装が C 言語のプログラムレベルでイメージできるようになることが、この本を読む目的でした。 学んだこと この本を通して学んだことを列挙します。
プログラムレベルでのプロトコルの解説 ネットワークプロトコルに必要な構造体、システムコール、ライブラリ関数の使い方とそれらの調査方法 socket システムコールを用いた UDP Client/UDP Server の実装 socket システムコールを用いた TCP Client/TCP Server の実装 パケットモニタリングを行い Ethernet/ARP/IP/ICMP/TCP/UDP のヘッダの解析 IP スキャン / TCP ポートスキャン / UDP ポートスキャン の実装 ARP 要求パケットや ARP 応答パケットを用いた対象のホストの ARP テーブルを書き換える攻撃手法の実装 ICMP redirect を用いた対象のホストのルーティングテーブルを書き換える攻撃手法の実装 IP ヘッダの TTL を用いた traceroute コマンドのようなものを実装 TCP のヘッダを作成し、SYN flood 攻撃の実装 TCP のヘッダを作成し、 ESTABLISHED な TCP のコネクションを強制的に切断する攻撃手法の実装 TCP のヘッダを作成し、TCP ジャックをする攻撃手法の実装 システムコールを用いた自作クライアントとサーバの実装、パケットモニタリング、攻撃手法の再現を通して、ネットワークプロトコルの構造や各レイヤーの関係性を学ぶことができました。読み応えのある非常に良い本でした。理解があやふやな箇所もあるので、期間を空けて本を読み直したいと思いました。</description></item><item><title>今年中に一つでも多く勉強したいこと</title><link>https://hakiwata.jp/post/20210518/</link><pubDate>Tue, 18 May 2021 04:27:07 +0900</pubDate><guid>https://hakiwata.jp/post/20210518/</guid><description>概要 こんにちは！最近は、ネットワーク周りのシステムコールやライブラリ関数の調査と検証が多く、わかりやすい進捗が出ていない気がしています。そこで、気晴らしに今年中に勉強したいことを洗い出してみました。一旦アウトプットすることで、頭の中がクリアになればと思っています。 勉強したい内容 今年入って勉強してきたことの上乗せ 基礎からわかるTCP/IP ネットワーク実験プログラミング（第2版） を読む
ネットワークのパケットを C 言語のプログラムレベルで理解したい。 ハロー“Hello, World” OSと標準ライブラリのシゴトとしくみ を読む
動的解析の観点からシステムコールを学びたい。 サイバーセキュリティプログラミング ―Pythonで学ぶハッカーの思考 を読む
セキュリティの観点から年のパケットをプログラムレベルで理解したい。 Hacking: 美しき策謀 第2版 ―脆弱性攻撃の理論と実際 を読む
今年に学んだことを PWN などに応用して、セキュリティ的な観点からも更に理解を深めたい。 低レベルプログラミング を読む
アセンブリ言語や C 言語や型システムを学びたい。 また、今年は、C 言語やアセンブリ言語を勉強してきたので、新たな書籍で体系的に学びたい。 例解UNIX/Linuxプログラミング教室: システムコールを使いこなすための12講 を読む
今年は、シスプロを多めに勉強してきたので、違う書籍の違う観点から新しい知見を得たい。 ふつうの Linux プログラミングの Http Server の章を読み直す</description></item><item><title>振り返り</title><link>https://hakiwata.jp/post/20210512/</link><pubDate>Wed, 12 May 2021 03:07:55 +0900</pubDate><guid>https://hakiwata.jp/post/20210512/</guid><description>概要 こんにちは！今年も月日が経つのが早く 1 年の内の 1/3 が過ぎ去ってしまいました。後輩や友達に今年に入って何を勉強してきたのかを聞かれることがたまにあるので、その記録を残していきたいと思います。基本的に大学院の課題や研究は除いています。 1 月 そもそも今年のテーマは Computer Science の基礎を固めることでした。もう少し具体的に言うと、OS, CPU, Network, Container の仕組みをコードレベルで勉強したいと考えていました。そこで、まずコンピュータの全体像を掴むために、以下の本を 2 月中旬まで読んでいました。
コンピュータシステムの理論と実装 ―モダンなコンピュータの作り方 この本は Nand to Tetris とも呼ばれるのですが、CPU を構成する回路 (例えば全加算器や ALU) を VHDL で実装して、エミュレータで動かすところからレイヤーを徐々に上げていきます。作成した基本的な回路を元に、CPU をエミュレートします。その後、機械語やアセンブリ言語やスタックを学び、VM、独自言語のコンパイラをインクリメンタルに実装していきます。この本と付随する演習問題を全て解くことを通して、 CPU や VM と言った普段は意識しない低レイヤなものの振る舞いをなんとなくイメージできるようになりました。
2 月 コンピュータシステムの理論と実装を読んで、特にアセンブリとコンパイラに興味を持ちました。そこで、以下の本と資料を読み始めました。
はじめて学ぶバイナリ解析　不正なコードからコンピュータを守るサイバーセキュリティ技術 低レイヤを知りたい人のためのCコンパイラ作成入門 前者に関しては、CTFer にはおなじみですが、セキュリティ的な観点からスタックやアセンブリを学べました。初心者向けの本だったので、コンピュータシステムの理論と実装の復習にもなり、学びになりました。
後者に関しては、 C 言語のコンパイラをテストコードと共にインクリメンタルに実装していくものです。このコンパイラを実装できれば、自作コンパイラのコードそのものや、xv6 をコンパイルできるとワクワクしていました。しかし、C 言語の理解が学部 1 年生レベルで止まっていたこともあり、型をコンパイルしてアセンブリを吐き出せるようになる手前で挫折してしまいました。毎日付けているノートを振り返ると、C 言語の理解の浅さとアセンブリ言語の知識が足りなかったと反省しています。</description></item><item><title>First Post</title><link>https://hakiwata.jp/post/20210430/</link><pubDate>Fri, 30 Apr 2021 03:03:17 +0900</pubDate><guid>https://hakiwata.jp/post/20210430/</guid><description>サイトの移行 こんにちは！もともと自分のポートフォリオは React と Django を用いて Amazon EC2 上にデプロイしていました。(リポジトリは hk-41 になります。) しかし、AWS Education で割り当てられたクレジットが切れたので、Hugo + GitHub Pages で新しく作り直しました。思い立って 2 時間ほどで移行できたので、非常に便利だと思いました。</description></item></channel></rss>