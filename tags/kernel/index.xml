<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kernel on haKiwata</title><link>https://hakiwata.jp/tags/kernel/</link><description>Recent content in Kernel on haKiwata</description><generator>Hugo -- gohugo.io</generator><copyright>&amp;copy; 2021 haKiwata</copyright><lastBuildDate>Sun, 17 Oct 2021 19:29:55 +0000</lastBuildDate><atom:link href="https://hakiwata.jp/tags/kernel/index.xml" rel="self" type="application/rss+xml"/><item><title>ゼロからのOS自作入門を読んで
OS を実装してみた</title><link>https://hakiwata.jp/post/20211018/</link><pubDate>Sun, 17 Oct 2021 19:29:55 +0000</pubDate><guid>https://hakiwata.jp/post/20211018/</guid><description>概要 こんにちは！今年の 8 月中旬からゼロからのOS自作入門を読んで紹介されている OS を一通り写経して作り上げてみました。そこで、今回はこの本を読むまでに何をしていたかを振り返りつつ、読もうと思ったきっかけや感想などを残したいと思います。 きっかけ 今年度で学生生活が最後で時間に余裕がある内に、コンピュータや OS について詳しくなりたいと思っていました。自分は普段から Ubuntu 18.04 を使っているのですが、低レイヤや Linux に詳しくありません。そのため、まず初めの取っ掛かりとして低レイヤ周りの本や資料を少しずつ読んだりしていました。例えば以下が挙げられます。
[試して理解]Linuxのしくみ ~実験と図解で学ぶOSとハードウェアの基礎知識 コンピュータシステムの理論と実装 ―モダンなコンピュータの作り方 低レイヤを知りたい人のためのCコンパイラ作成入門 ふつうのLinuxプログラミング 第2版 Linuxの仕組みから学べるgccプログラミングの王道 基礎からわかるTCP/IP ネットワーク実験プログラミング（第2版） Hacking: 美しき策謀 第2版 ―脆弱性攻撃の理論と実際 ハロー“Hello, World” OSと標準ライブラリのシゴトとしくみ このように Linux や低レイヤに興味がありつつ、大学の先輩が Linux Kernel にコントリビュートし楽しそうにしている様子を見たり、研究室の隣の同期がこの本を読み切ったりしていて、今始めることがチャンスだと思い、思い切って初めてみました。
感想 OS を一から作り上げる行為は、低レイヤの総合格闘技感があり、非常に楽しかったです。この本を通して個人的に特に面白かった箇所を抜粋して挙げていきます。
一番初めの Hello World を出力できた時 C++ で実装できないロジックをアセンブリ言語で実装した時 割り込みを実装し、メッセージを送受信できた時 コンテキストスイッチの実装を知った時 Priority Queue を使ってタスクに優先度を付け、タスクを Sleep/Running できるように実装した時 初めてシステムコールを実装した時 ファイルの書き込みファイルディスクリプタで抽象化した時 ページフォルトを活用してデマンドページングを実装した時 実装のバグを調査するために printk や Log でデバッグをたくさんした時 この本を読んだ研究室の同期と OS の機能に関する実装に関する議論ができたこと また、細かい日記に関しては以下に記述しました。全く書いていない箇所もあればデバッグが辛かった様子を書いたりしていて、内容に関してはまちまちです。</description></item><item><title>自作 OS 日記 (3)</title><link>https://hakiwata.jp/post/20210901/</link><pubDate>Wed, 01 Sep 2021 19:11:00 +0000</pubDate><guid>https://hakiwata.jp/post/20210901/</guid><description>概要 こんにちは！前回に引き続き自作 OS 日記を付けたいと思います。このエントリでは 21 ~ 30 章までの記録を残したいと思います。 日記 2021 年 9 月 25 日 osbook_day21a IST を設定しました！ osbook_day21b rpn コマンド で引き算した結果をターミナルに出力するためのシステムコールを実装した。だいぶ身近な箇所の実装にまで辿り着いてさらに楽しくなってきた。 2021 年 9 月 26 日 osbook_day21c 終了のシステムコールを実装しました！この実装により、rpn コマンドで足し算や引き算をした結果を出力し、制御をターミナルに戻すことができます。 今回は、解説されているプログラムをアプリケーション側から写経していきました。つまり、apps/rpn/rpn.cpp の main 関数 内で SyscallExit を呼び出すことから実装を始めました。これは、前節ではアセンブリから実装を始めたので、視点を変えたかったためです。
この節を実装して特に感じたことがあります。それは、節によっては説明が前後するため、紹介されているプログラムを読んで直後の解説を読んでもわけがわからないときが多々あることです。自分は紹介されているプログラムが自分で理解できる時は、プログラムを読んで自分なりの解釈を作ってから直後に書かれている解説を読むようにしています。しかし、プログラムを読んでなぜこの実装にしたのかの意図が全くわからず、直後の解説を読んでも特に触れられていない時があります。その時は、その実装の解釈に対してめちゃくちゃ悩み、妥協して読み進めるしかありません。そして、読み進めると、後の方のページでそのプログラムに対する解説を見つけると、何やねんと思ったりすることもありました。紙面や解説の都合上こうなるのはしょうがないと思うのですが、おいってなります。そのため、自分のこの本の読み方を改めつつ、もっと多くの知識を付けたいと思いました。
2021 年 9 月 27 日 osbook_day21d アプリケーションが増えてきたので、アプリケーションのリファクタリングを行いました。UI に特に変更はありません。 osbook_day21e ウィンドウを開くシステムコールを実装しました。 osbook_day21f 前節で実装したシステムコールに機能を加え、開いたウィンドウに文字を表示させました。 2021 年 9 月 28 日 osbook_day22a exit システムコール を実装しました。これまで SyscallExit と記述していた実装を exit に書き換えて C の標準ライブラリを使うように修正しました。しかし、以下のように _exit が定義されていないというエラ−が出ます。そこで、エラーログに書かれているように apps/newlib_support.</description></item><item><title>自作 OS 日記 (2)</title><link>https://hakiwata.jp/post/20210831/</link><pubDate>Mon, 30 Aug 2021 19:11:00 +0000</pubDate><guid>https://hakiwata.jp/post/20210831/</guid><description>概要 こんにちは！前回に引き続き自作 OS 日記を付けたいと思います。このエントリでは 11 ~ 20 章までの記録を残したいと思います。 日記 2021 年 9 月 1 日 osbook_day11a main 関数のリファクタリングを行いました。main 関数が大きすぎて大変でした。見た目の挙動は osbook_day10g と変わりません。 osbook_day11b 周期的に割り込むタイマを実装しました。一定のカウントが刻まれると、割り込みが入り、背景に文字列が表示されます。 osbook_day11c 前節よりも短い周期で割り込みを行わせ、その割り込み回数を計算します。 2021 年 9 月 2 日 osbook_day11d 複数のタイマを作成し、それらからのタイムアウト通知を受け取ることができるように修正しました。 osbook_day11e Kernel で Root System Description Pointer を取得できるように修正しました。これは、後々 IO ポート番号を求めるのに役立ちます。 osbook_day12a IO ポート番号を求めるのに必要な FADT というテーブルのデータを取得する実装を行いました。UI に変化はありません。 2021 年 9 月 3 日 osbook_day12b ACPI PM タイマ (基準となる軸で、fadt-&amp;gt;pm_tmr_blk から求められる。) を使用して Local APIC タイマの 1 カウントが何秒なのかを計測します。 osbook_day12c osbook_day12d osbook_day12e osbook_day12f 2021 年 9 月 4 日 osbook_day13a 協調的マルチタスクの機能を実装しました！ osbook_day13b プリミティブなプリエンプティブマルチタスクの機能を実装しました！特にコンテキストスイッチの自動化を行いました。 osbook_day13c マルチタスクが実装できるかを検証しました。Hello Window と TaskB Window のカウンタが 1 秒おきに切り替わっていることがわかります。しかし、カウンタは 2 秒間分のカウントを刻んでいます。 osbook_day13d マルチタスクを管理するための TaskManager を実装しました。タスクを増やせば増やすほどマウスがカクつく問題が生じたので、次章以降で修正していきたいと思います！ 2021 年 9 月 5 日 osbook_day14a ランキューを作成して実行可能状態にあるタスクを保持する。処理が完了したタスクをランキューから取り出し Sleep させ、CPU が割り当てられないような機能を実装する。この節では、キーボードからの入力でタスクを Sleep させるか Wakeup させるかを適宜切り替える。 osbook_day14b osbook_day14c osbook_day14d 2021 年 9 月 6 日 osbook_day15a ウィンドウの描画をメインスレッドで行うようにリファクタリングを行いました！これまでは TaskB とメインタスクの両方で画面の再描画を行っていました。しかし、それが原因でデータをの競合が発生し、ウィンドウを動かすと、そのゴミが残ってしまっていました。 osbook_day15b ウィンドウにアクティブ/非アクティブの機能を追加しました！ この節通りにプログラムを実装すると、実行後すぐに TaskB のウィンドウが消えてしまいます。状況を切り分けてトラブルシューティングすると、main.</description></item><item><title>自作 OS 日記 (1)</title><link>https://hakiwata.jp/post/20210830/</link><pubDate>Sun, 29 Aug 2021 19:11:00 +0000</pubDate><guid>https://hakiwata.jp/post/20210830/</guid><description>概要 こんにちは！最近、研究室の隣の同期に影響されて自作 OS を始めました。そこで、今回は自作 OS が成長していく様子を日記としてこの記事に残したいと思います。このエントリでは 1 ~ 10 章までの記録を残したいと思います。 日記 2021 年 8 月 13 日 osbook_day01 自作 OS を始めました！名前は HonOS です！名前の由来は櫻坂46 の田村保乃ちゃんのあだ名の「ほのす」から付けました。 2021 年 8 月 28 日 osbook_day09b osbook_day09c osbook_day09d 2021 年 8 月 29 日 osbook_day09e 2021 年 8 月 29 日 osbook_day10a osbook_day10b-invalid FrameBuffer::Copy の実装が間違っていたせいで表示がバグってしまいました。状況を切り分けつつバグを調査する過程が最高に楽しかったです。 osbook_day10b ウィンドウを表示することができました！ osbook_day10c Kernel の main 関数の for ループ回数を書き込んだウィンドウを表示することができました！ 2021 年 8 月 30 日 しかし、この記事を見た同期に表示されている色の挙動がおかしいと指摘されました。そこで、osbook_day10c に checkout し、正常系の挙動を確認してみました。そうすると、確かに正常系と比較すると、挙動がおかしかったので、バグを調査し修正しました。原因は constexpr PixelColor ToColor(uint32_t c); の色のビットシフトが逆になっていたことでした。だいぶ画面がチカチカしていますが、そのリファクタリングは次節以降でできればと思っています！ 2021 年 8 月 31 日 osbook_day10d osbook_day10e この節では、バックバッファに描画を行った後に、バックバッファをフレームバッファに転送を行います。こうして転送を行うことで、マウスカーソルが表示されない期間を完全になくし、カウンタにマウスを重ねた時のチラツキをなくすことができます。 参考 ゼロからOS自作入門 10章 【OpenGLでゲームを作る】ダブルバッファリングとは ダブルバッファリング 【double buffering】 描画処理について osbook_day10f USB ドライバからデータを取り出すプログラムは、マウスのボタンが押されたかとマウスがどれだけ移動したかの変位を取得できる機能のものでした。しかし、なぜかドライバから Kernel にそれらのデータが渡されませんでした。make clean や rm kernel.</description></item></channel></rss>