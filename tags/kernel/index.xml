<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Kernel on haKiwata</title><link>https://hakiwata.jp/tags/kernel/</link><description>Recent content in Kernel on haKiwata</description><generator>Hugo -- gohugo.io</generator><copyright>&amp;copy; 2021 haKiwata</copyright><lastBuildDate>Wed, 01 Sep 2021 19:11:00 +0000</lastBuildDate><atom:link href="https://hakiwata.jp/tags/kernel/index.xml" rel="self" type="application/rss+xml"/><item><title>自作 OS 日記 (3)</title><link>https://hakiwata.jp/post/20210901/</link><pubDate>Wed, 01 Sep 2021 19:11:00 +0000</pubDate><guid>https://hakiwata.jp/post/20210901/</guid><description>概要 こんにちは！前回に引き続き自作 OS 日記を付けたいと思います。このエントリでは 21 ~ 30 章までの記録を残したいと思います。 日記 2021 年 9 月 25 日 osbook_day21a IST を設定しました！ osbook_day21b rpn コマンド で引き算した結果をターミナルに出力するためのシステムコールを実装した。だいぶ身近な箇所の実装にまで辿り着いてさらに楽しくなってきた。 2021 年 9 月 26 日 osbook_day21c 終了のシステムコールを実装しました！この実装により、rpn コマンドで足し算や引き算をした結果を出力し、制御をターミナルに戻すことができます。 今回は、解説されているプログラムをアプリケーション側から写経していきました。つまり、apps/rpn/rpn.cpp の main 関数 内で SyscallExit を呼び出すことから実装を始めました。これは、前節ではアセンブリから実装を始めたので、視点を変えたかったためです。
この節を実装して特に感じたことがあります。それは、節によっては説明が前後するため、紹介されているプログラムを読んで直後の解説を読んでもわけがわからないときが多々あることです。自分は紹介されているプログラムが自分で理解できる時は、プログラムを読んで自分なりの解釈を作ってから直後に書かれている解説を読むようにしています。しかし、プログラムを読んでなぜこの実装にしたのかの意図が全くわからず、直後の解説を読んでも特に触れられていない時があります。その時は、その実装の解釈に対してめちゃくちゃ悩み、妥協して読み進めるしかありません。そして、読み進めると、後の方のページでそのプログラムに対する解説を見つけると、何やねんと思ったりすることもありました。紙面や解説の都合上こうなるのはしょうがないと思うのですが、おいってなります。そのため、自分のこの本の読み方を改めつつ、もっと多くの知識を付けたいと思いました。
2021 年 9 月 27 日 osbook_day21d アプリケーションが増えてきたので、アプリケーションのリファクタリングを行いました。UI に特に変更はありません。 osbook_day21e ウィンドウを開くシステムコールを実装しました。 osbook_day21f 前節で実装したシステムコールに機能を加え、開いたウィンドウに文字を表示させました。 2021 年 9 月 28 日 osbook_day22a exit システムコール を実装しました。これまで SyscallExit と記述していた実装を exit に書き換えて C の標準ライブラリを使うように修正しました。しかし、以下のように _exit が定義されていないというエラ−が出ます。そこで、エラーログに書かれているように apps/newlib_support.</description></item><item><title>自作 OS 日記 (2)</title><link>https://hakiwata.jp/post/20210831/</link><pubDate>Mon, 30 Aug 2021 19:11:00 +0000</pubDate><guid>https://hakiwata.jp/post/20210831/</guid><description>概要 こんにちは！前回に引き続き自作 OS 日記を付けたいと思います。このエントリでは 11 ~ 20 章までの記録を残したいと思います。 日記 2021 年 9 月 1 日 osbook_day11a main 関数のリファクタリングを行いました。main 関数が大きすぎて大変でした。見た目の挙動は osbook_day10g と変わりません。 osbook_day11b 周期的に割り込むタイマを実装しました。一定のカウントが刻まれると、割り込みが入り、背景に文字列が表示されます。 osbook_day11c 前節よりも短い周期で割り込みを行わせ、その割り込み回数を計算します。 2021 年 9 月 2 日 osbook_day11d 複数のタイマを作成し、それらからのタイムアウト通知を受け取ることができるように修正しました。 osbook_day11e Kernel で Root System Description Pointer を取得できるように修正しました。これは、後々 IO ポート番号を求めるのに役立ちます。 osbook_day12a IO ポート番号を求めるのに必要な FADT というテーブルのデータを取得する実装を行いました。UI に変化はありません。 2021 年 9 月 3 日 osbook_day12b ACPI PM タイマ (基準となる軸で、fadt-&amp;gt;pm_tmr_blk から求められる。) を使用して Local APIC タイマの 1 カウントが何秒なのかを計測します。 osbook_day12c osbook_day12d osbook_day12e osbook_day12f 2021 年 9 月 4 日 osbook_day13a 協調的マルチタスクの機能を実装しました！ osbook_day13b プリミティブなプリエンプティブマルチタスクの機能を実装しました！特にコンテキストスイッチの自動化を行いました。 osbook_day13c マルチタスクが実装できるかを検証しました。Hello Window と TaskB Window のカウンタが 1 秒おきに切り替わっていることがわかります。しかし、カウンタは 2 秒間分のカウントを刻んでいます。 osbook_day13d マルチタスクを管理するための TaskManager を実装しました。タスクを増やせば増やすほどマウスがカクつく問題が生じたので、次章以降で修正していきたいと思います！ 2021 年 9 月 5 日 osbook_day14a ランキューを作成して実行可能状態にあるタスクを保持する。処理が完了したタスクをランキューから取り出し Sleep させ、CPU が割り当てられないような機能を実装する。この節では、キーボードからの入力でタスクを Sleep させるか Wakeup させるかを適宜切り替える。 osbook_day14b osbook_day14c osbook_day14d 2021 年 9 月 6 日 osbook_day15a ウィンドウの描画をメインスレッドで行うようにリファクタリングを行いました！これまでは TaskB とメインタスクの両方で画面の再描画を行っていました。しかし、それが原因でデータをの競合が発生し、ウィンドウを動かすと、そのゴミが残ってしまっていました。 osbook_day15b ウィンドウにアクティブ/非アクティブの機能を追加しました！ この節通りにプログラムを実装すると、実行後すぐに TaskB のウィンドウが消えてしまいます。状況を切り分けてトラブルシューティングすると、main.</description></item><item><title>自作 OS 日記 (1)</title><link>https://hakiwata.jp/post/20210830/</link><pubDate>Sun, 29 Aug 2021 19:11:00 +0000</pubDate><guid>https://hakiwata.jp/post/20210830/</guid><description>概要 こんにちは！最近、研究室の隣の同期に影響されて自作 OS を始めました。そこで、今回は自作 OS が成長していく様子を日記としてこの記事に残したいと思います。このエントリでは 1 ~ 10 章までの記録を残したいと思います。 日記 2021 年 8 月 13 日 osbook_day01 自作 OS を始めました！名前は HonOS です！名前の由来は櫻坂46 の田村保乃ちゃんのあだ名の「ほのす」から付けました。 2021 年 8 月 28 日 osbook_day09b osbook_day09c osbook_day09d 2021 年 8 月 29 日 osbook_day09e 2021 年 8 月 29 日 osbook_day10a osbook_day10b-invalid FrameBuffer::Copy の実装が間違っていたせいで表示がバグってしまいました。状況を切り分けつつバグを調査する過程が最高に楽しかったです。 osbook_day10b ウィンドウを表示することができました！ osbook_day10c Kernel の main 関数の for ループ回数を書き込んだウィンドウを表示することができました！ 2021 年 8 月 30 日 しかし、この記事を見た同期に表示されている色の挙動がおかしいと指摘されました。そこで、osbook_day10c に checkout し、正常系の挙動を確認してみました。そうすると、確かに正常系と比較すると、挙動がおかしかったので、バグを調査し修正しました。原因は constexpr PixelColor ToColor(uint32_t c); の色のビットシフトが逆になっていたことでした。だいぶ画面がチカチカしていますが、そのリファクタリングは次節以降でできればと思っています！ 2021 年 8 月 31 日 osbook_day10d osbook_day10e この節では、バックバッファに描画を行った後に、バックバッファをフレームバッファに転送を行います。こうして転送を行うことで、マウスカーソルが表示されない期間を完全になくし、カウンタにマウスを重ねた時のチラツキをなくすことができます。 参考 ゼロからOS自作入門 10章 【OpenGLでゲームを作る】ダブルバッファリングとは ダブルバッファリング 【double buffering】 描画処理について osbook_day10f USB ドライバからデータを取り出すプログラムは、マウスのボタンが押されたかとマウスがどれだけ移動したかの変位を取得できる機能のものでした。しかし、なぜかドライバから Kernel にそれらのデータが渡されませんでした。make clean や rm kernel.</description></item></channel></rss>